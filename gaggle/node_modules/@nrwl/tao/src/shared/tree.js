"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printChanges = exports.flushChanges = exports.FsTree = void 0;
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const logger_1 = require("./logger");
const path_1 = require("path");
const chalk = require('chalk');
class FsTree {
    constructor(root, isVerbose) {
        this.root = root;
        this.isVerbose = isVerbose;
        this.recordedChanges = {};
    }
    read(filePath) {
        filePath = this.normalize(filePath);
        try {
            if (this.recordedChanges[this.rp(filePath)]) {
                return this.recordedChanges[this.rp(filePath)].content;
            }
            else {
                return this.fsReadFile(filePath);
            }
        }
        catch (e) {
            if (this.isVerbose) {
                logger_1.logger.error(e);
            }
            return null;
        }
    }
    write(filePath, content) {
        filePath = this.normalize(filePath);
        if (this.fsExists(this.rp(filePath)) &&
            Buffer.from(content).equals(this.fsReadFile(filePath))) {
            // Remove recorded change because the file has been restored to it's original contents
            delete this.recordedChanges[this.rp(filePath)];
            return;
        }
        try {
            this.recordedChanges[this.rp(filePath)] = {
                content: Buffer.from(content),
                isDeleted: false,
            };
        }
        catch (e) {
            if (this.isVerbose) {
                logger_1.logger.error(e);
            }
        }
    }
    overwrite(filePath, content) {
        filePath = this.normalize(filePath);
        this.write(filePath, content);
    }
    delete(filePath) {
        filePath = this.normalize(filePath);
        if (this.filesForDir(this.rp(filePath)).length > 0) {
            this.filesForDir(this.rp(filePath)).forEach((f) => (this.recordedChanges[f] = { content: null, isDeleted: true }));
        }
        this.recordedChanges[this.rp(filePath)] = {
            content: null,
            isDeleted: true,
        };
        // Delete directories when
        if (this.exists(path_1.dirname(this.rp(filePath))) &&
            this.children(path_1.dirname(this.rp(filePath))).length < 1) {
            this.delete(path_1.dirname(this.rp(filePath)));
        }
    }
    exists(filePath) {
        filePath = this.normalize(filePath);
        try {
            if (this.recordedChanges[this.rp(filePath)]) {
                return !this.recordedChanges[this.rp(filePath)].isDeleted;
            }
            else if (this.filesForDir(this.rp(filePath)).length > 0) {
                return true;
            }
            else {
                return this.fsExists(filePath);
            }
        }
        catch (err) {
            return false;
        }
    }
    rename(from, to) {
        from = this.normalize(from);
        to = this.normalize(to);
        const content = this.read(this.rp(from));
        this.delete(this.rp(from));
        this.write(this.rp(to), content);
    }
    isFile(filePath) {
        filePath = this.normalize(filePath);
        try {
            if (this.recordedChanges[this.rp(filePath)]) {
                return !this.recordedChanges[this.rp(filePath)].isDeleted;
            }
            else {
                return this.fsIsFile(filePath);
            }
        }
        catch (err) {
            return false;
        }
    }
    children(dirPath) {
        dirPath = this.normalize(dirPath);
        let res = this.fsReadDir(dirPath);
        res = [...res, ...this.directChildrenOfDir(this.rp(dirPath))];
        res = res.filter((q) => {
            const r = this.recordedChanges[path_1.join(this.rp(dirPath), q)];
            return !(r === null || r === void 0 ? void 0 : r.isDeleted);
        });
        // Dedupe
        return Array.from(new Set(res));
    }
    listChanges() {
        const res = [];
        Object.keys(this.recordedChanges).forEach((f) => {
            if (this.recordedChanges[f].isDeleted) {
                if (this.fsExists(f)) {
                    res.push({ path: f, type: 'DELETE', content: null });
                }
            }
            else {
                if (this.fsExists(f)) {
                    res.push({
                        path: f,
                        type: 'UPDATE',
                        content: this.recordedChanges[f].content,
                    });
                }
                else {
                    res.push({
                        path: f,
                        type: 'CREATE',
                        content: this.recordedChanges[f].content,
                    });
                }
            }
        });
        return res;
    }
    normalize(path) {
        return path_1.relative(this.root, path_1.join(this.root, path)).split(path_1.sep).join('/');
    }
    fsReadDir(dirPath) {
        if (!this.delegateToFs)
            return [];
        try {
            return fs_1.readdirSync(path_1.join(this.root, dirPath));
        }
        catch (e) {
            return [];
        }
    }
    fsIsFile(filePath) {
        if (!this.delegateToFs)
            return false;
        const stat = fs_1.statSync(path_1.join(this.root, filePath));
        return stat.isFile();
    }
    fsReadFile(filePath) {
        if (!this.delegateToFs)
            return null;
        return fs_1.readFileSync(path_1.join(this.root, filePath));
    }
    fsExists(filePath) {
        if (!this.delegateToFs)
            return false;
        try {
            const stat = fs_1.statSync(path_1.join(this.root, filePath));
            return stat.isFile() || stat.isDirectory();
        }
        catch (e) {
            return false;
        }
    }
    delegateToFs() {
        return this.root !== null;
    }
    filesForDir(path) {
        return Object.keys(this.recordedChanges).filter((f) => f.startsWith(path + '/') && !this.recordedChanges[f].isDeleted);
    }
    directChildrenOfDir(path) {
        const res = {};
        if (path === '') {
            return Object.keys(this.recordedChanges).map((file) => file.split('/')[0]);
        }
        Object.keys(this.recordedChanges).forEach((f) => {
            if (f.startsWith(path + '/')) {
                const [_, file] = f.split(path + '/');
                res[file.split('/')[0]] = true;
            }
        });
        return Object.keys(res);
    }
    rp(pp) {
        return pp.startsWith('/') ? pp.substring(1) : pp;
    }
}
exports.FsTree = FsTree;
function flushChanges(root, fileChanges) {
    fileChanges.forEach((f) => {
        const fpath = path_1.join(root, f.path);
        if (f.type === 'CREATE') {
            fs_extra_1.mkdirpSync(path_1.dirname(fpath));
            fs_1.writeFileSync(fpath, f.content);
        }
        else if (f.type === 'UPDATE') {
            fs_1.writeFileSync(fpath, f.content);
        }
        else if (f.type === 'DELETE') {
            try {
                const stat = fs_1.statSync(fpath);
                if (stat.isDirectory()) {
                    fs_extra_1.rmdirSync(fpath, { recursive: true });
                }
                else {
                    fs_1.unlinkSync(fpath);
                }
            }
            catch (e) { }
        }
    });
}
exports.flushChanges = flushChanges;
function printChanges(fileChanges) {
    fileChanges.forEach((f) => {
        if (f.type === 'CREATE') {
            console.log(`${chalk.green('CREATE')} ${f.path}`);
        }
        else if (f.type === 'UPDATE') {
            console.log(`${chalk.white('UPDATE')} ${f.path}`);
        }
        else if (f.type === 'DELETE') {
            console.log(`${chalk.yellow('DELETE')} ${f.path}`);
        }
    });
}
exports.printChanges = printChanges;
//# sourceMappingURL=tree.js.map