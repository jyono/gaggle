"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toOldFormatOrNull = exports.toNewFormatOrNull = exports.toNewFormat = exports.reformattedWorkspaceJsonOrNull = exports.Workspaces = exports.workspaceConfigName = void 0;
const fs = require("fs");
const path = require("path");
const stripJsonComments = require("strip-json-comments");
require("../compat/compat");
function workspaceConfigName(root) {
    try {
        fs.statSync(path.join(root, 'angular.json'));
        return 'angular.json';
    }
    catch (e) {
        return 'workspace.json';
    }
}
exports.workspaceConfigName = workspaceConfigName;
class Workspaces {
    constructor(root) {
        this.root = root;
    }
    relativeCwd(cwd) {
        return path.relative(this.root, cwd) || null;
    }
    calculateDefaultProjectName(cwd, wc) {
        const relativeCwd = this.relativeCwd(cwd);
        if (relativeCwd) {
            const matchingProject = Object.keys(wc.projects).find((p) => {
                const projectRoot = wc.projects[p].root;
                return (relativeCwd == projectRoot ||
                    relativeCwd.startsWith(`${projectRoot}/`));
            });
            if (matchingProject)
                return matchingProject;
        }
        return wc.defaultProject;
    }
    readWorkspaceConfiguration() {
        const w = JSON.parse(stripJsonComments(fs
            .readFileSync(path.join(this.root, workspaceConfigName(this.root)))
            .toString()));
        return toNewFormat(w);
    }
    isNxExecutor(nodeModule, executor) {
        const schema = this.readExecutor(nodeModule, executor).schema;
        return schema['cli'] === 'nx';
    }
    isNxGenerator(collectionName, generatorName) {
        const schema = this.readGenerator(collectionName, generatorName).schema;
        return schema['cli'] === 'nx';
    }
    readExecutor(nodeModule, executor) {
        try {
            const { executorsFilePath, executorConfig } = this.readExecutorsJson(nodeModule, executor);
            const executorsDir = path.dirname(executorsFilePath);
            const schemaPath = path.join(executorsDir, executorConfig.schema || '');
            const schema = JSON.parse(stripJsonComments(fs.readFileSync(schemaPath).toString()));
            if (!schema.properties || typeof schema.properties !== 'object') {
                schema.properties = {};
            }
            const [modulePath, exportName] = executorConfig.implementation.split('#');
            const implementationFactory = () => {
                const module = require(path.join(executorsDir, modulePath));
                return module[exportName || 'default'];
            };
            return { schema, implementationFactory };
        }
        catch (e) {
            throw new Error(`Unable to resolve ${nodeModule}:${executor}.\n${e.message}`);
        }
    }
    readGenerator(collectionName, generatorName) {
        var _a, _b;
        try {
            const { generatorsFilePath, generatorsJson, normalizedGeneratorName, } = this.readGeneratorsJson(collectionName, generatorName);
            const generatorsDir = path.dirname(generatorsFilePath);
            const generatorConfig = ((_a = generatorsJson.generators) === null || _a === void 0 ? void 0 : _a[normalizedGeneratorName]) || ((_b = generatorsJson.schematics) === null || _b === void 0 ? void 0 : _b[normalizedGeneratorName]);
            const schemaPath = path.join(generatorsDir, generatorConfig.schema || '');
            const schema = JSON.parse(stripJsonComments(fs.readFileSync(schemaPath).toString()));
            if (!schema.properties || typeof schema.properties !== 'object') {
                schema.properties = {};
            }
            generatorConfig.implementation =
                generatorConfig.implementation || generatorConfig.factory;
            const [modulePath, exportName] = generatorConfig.implementation.split('#');
            const implementationFactory = () => {
                const module = require(path.join(generatorsDir, modulePath));
                return module[exportName || 'default'];
            };
            return { normalizedGeneratorName, schema, implementationFactory };
        }
        catch (e) {
            throw new Error(`Unable to resolve ${collectionName}:${generatorName}.\n${e.message}`);
        }
    }
    readExecutorsJson(nodeModule, executor) {
        var _a, _b;
        const packageJsonPath = require.resolve(`${nodeModule}/package.json`, {
            paths: this.resolvePaths(),
        });
        const packageJson = JSON.parse(stripJsonComments(fs.readFileSync(packageJsonPath).toString()));
        const executorsFile = packageJson.executors
            ? packageJson.executors
            : packageJson.builders;
        if (!executorsFile) {
            throw new Error(`The "${nodeModule}" package does not support Nx executors.`);
        }
        const executorsFilePath = require.resolve(path.join(path.dirname(packageJsonPath), executorsFile));
        const executorsJson = JSON.parse(stripJsonComments(fs.readFileSync(executorsFilePath).toString()));
        const executorConfig = ((_a = executorsJson.executors) === null || _a === void 0 ? void 0 : _a[executor]) || ((_b = executorsJson.builders) === null || _b === void 0 ? void 0 : _b[executor]);
        if (!executorConfig) {
            throw new Error(`Cannot find executor '${executor}' in ${executorsFilePath}.`);
        }
        return { executorsFilePath, executorConfig };
    }
    readGeneratorsJson(collectionName, generator) {
        let generatorsFilePath;
        if (collectionName.endsWith('.json')) {
            generatorsFilePath = require.resolve(collectionName, {
                paths: this.resolvePaths(),
            });
        }
        else {
            const packageJsonPath = require.resolve(`${collectionName}/package.json`, {
                paths: this.resolvePaths(),
            });
            const packageJson = JSON.parse(stripJsonComments(fs.readFileSync(packageJsonPath).toString()));
            const generatorsFile = packageJson.generators
                ? packageJson.generators
                : packageJson.schematics;
            if (!generatorsFile) {
                throw new Error(`The "${collectionName}" package does not support Nx generators.`);
            }
            generatorsFilePath = require.resolve(path.join(path.dirname(packageJsonPath), generatorsFile));
        }
        const generatorsJson = JSON.parse(stripJsonComments(fs.readFileSync(generatorsFilePath).toString()));
        let normalizedGeneratorName = findFullGeneratorName(generator, generatorsJson.generators) ||
            findFullGeneratorName(generator, generatorsJson.schematics);
        if (!normalizedGeneratorName) {
            for (let parent of generatorsJson.extends || []) {
                try {
                    return this.readGeneratorsJson(parent, generator);
                }
                catch (e) { }
            }
            throw new Error(`Cannot find generator '${generator}' in ${generatorsFilePath}.`);
        }
        return { generatorsFilePath, generatorsJson, normalizedGeneratorName };
    }
    resolvePaths() {
        return this.root ? [this.root, __dirname] : [__dirname];
    }
}
exports.Workspaces = Workspaces;
function findFullGeneratorName(name, generators) {
    if (generators) {
        for (let [key, data] of Object.entries(generators)) {
            if (key === name ||
                (data.aliases && data.aliases.includes(name))) {
                return key;
            }
        }
    }
}
function reformattedWorkspaceJsonOrNull(w) {
    return w.version === 2 ? toNewFormatOrNull(w) : toOldFormatOrNull(w);
}
exports.reformattedWorkspaceJsonOrNull = reformattedWorkspaceJsonOrNull;
function toNewFormat(w) {
    const f = toNewFormatOrNull(w);
    return f ? f : w;
}
exports.toNewFormat = toNewFormat;
function toNewFormatOrNull(w) {
    let formatted = false;
    Object.values(w.projects || {}).forEach((project) => {
        if (project.architect) {
            renameProperty(project, 'architect', 'targets');
            formatted = true;
        }
        if (project.schematics) {
            renameProperty(project, 'schematics', 'generators');
            formatted = true;
        }
        Object.values(project.targets || {}).forEach((target) => {
            if (target.builder) {
                renameProperty(target, 'builder', 'executor');
                formatted = true;
            }
        });
    });
    if (w.schematics) {
        renameProperty(w, 'schematics', 'generators');
        formatted = true;
    }
    if (w.version !== 2) {
        w.version = 2;
        formatted = true;
    }
    return formatted ? w : null;
}
exports.toNewFormatOrNull = toNewFormatOrNull;
function toOldFormatOrNull(w) {
    let formatted = false;
    Object.values(w.projects || {}).forEach((project) => {
        if (project.targets) {
            renameProperty(project, 'targets', 'architect');
            formatted = true;
        }
        if (project.generators) {
            renameProperty(project, 'generators', 'schematics');
            formatted = true;
        }
        Object.values(project.architect || {}).forEach((target) => {
            if (target.executor) {
                renameProperty(target, 'executor', 'builder');
                formatted = true;
            }
        });
    });
    if (w.generators) {
        renameProperty(w, 'generators', 'schematics');
        formatted = true;
    }
    if (w.version !== 1) {
        w.version = 1;
        formatted = true;
    }
    return formatted ? w : null;
}
exports.toOldFormatOrNull = toOldFormatOrNull;
// we have to do it this way to preserve the order of properties
// not to screw up the formatting
function renameProperty(obj, from, to) {
    const copy = Object.assign({}, obj);
    Object.keys(obj).forEach((k) => {
        delete obj[k];
    });
    Object.keys(copy).forEach((k) => {
        if (k === from) {
            obj[to] = copy[k];
        }
        else {
            obj[k] = copy[k];
        }
    });
}
//# sourceMappingURL=workspace.js.map