"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = exports.invokeNew = exports.wrapAngularDevkitSchematic = exports.mockSchematicsForTesting = exports.overrideCollectionResolutionForTesting = exports.runMigration = exports.generate = exports.NxScopeHostUsedForWrappedSchematics = exports.NxScopedHostForMigrations = exports.NxScopedHost = exports.scheduleTarget = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-restricted-imports */
const core_1 = require("@angular-devkit/core");
const chalk = require("chalk");
const node_1 = require("@angular-devkit/core/node");
const fs_1 = require("fs");
const package_manager_1 = require("@nrwl/tao/src/shared/package-manager");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const path = require("path");
const path_1 = require("path");
const stripJsonComments = require("strip-json-comments");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const logger_1 = require("../shared/logger");
function scheduleTarget(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { Architect } = require('@angular-devkit/architect');
        const { WorkspaceNodeModulesArchitectHost, } = require('@angular-devkit/architect/node');
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const { workspace } = yield core_1.workspaces.readWorkspace(workspace_1.workspaceConfigName(root), core_1.workspaces.createWorkspaceHost(fsHost));
        const registry = new core_1.json.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const architectHost = new WorkspaceNodeModulesArchitectHost(workspace, root);
        const architect = new Architect(architectHost, registry);
        const run = yield architect.scheduleTarget({
            project: opts.project,
            target: opts.target,
            configuration: opts.configuration,
        }, opts.runOptions, { logger });
        return run.output;
    });
}
exports.scheduleTarget = scheduleTarget;
function createWorkflow(fsHost, root, opts) {
    const NodeWorkflow = require('@angular-devkit/schematics/tools').NodeWorkflow;
    const workflow = new NodeWorkflow(fsHost, {
        force: opts.force,
        dryRun: opts.dryRun,
        packageManager: package_manager_1.detectPackageManager(),
        root: core_1.normalize(root),
        registry: new core_1.schema.CoreSchemaRegistry(require('@angular-devkit/schematics').formats.standardFormats),
        resolvePaths: [process.cwd(), root],
    });
    workflow.registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
    workflow.engineHost.registerOptionsTransform(require('@angular-devkit/schematics/tools').validateOptionsWithSchema(workflow.registry));
    return workflow;
}
function getCollection(workflow, name) {
    const collection = workflow.engine.createCollection(name);
    if (!collection)
        throw new Error(`Cannot find collection '${name}'`);
    return collection;
}
function createRecorder(host, record, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const actualConfigName = yield host.workspaceConfigName();
        return (event) => {
            let eventPath = event.path.startsWith('/')
                ? event.path.substr(1)
                : event.path;
            if (eventPath === 'workspace.json' || eventPath === 'angular.json') {
                eventPath = actualConfigName;
            }
            if (event.kind === 'error') {
                record.error = true;
                logger.warn(`ERROR! ${eventPath} ${event.description == 'alreadyExist'
                    ? 'already exists'
                    : 'does not exist.'}.`);
            }
            else if (event.kind === 'update') {
                record.loggingQueue.push(core_1.tags.oneLine `${chalk.white('UPDATE')} ${eventPath}`);
            }
            else if (event.kind === 'create') {
                record.loggingQueue.push(core_1.tags.oneLine `${chalk.green('CREATE')} ${eventPath}`);
            }
            else if (event.kind === 'delete') {
                record.loggingQueue.push(`${chalk.yellow('DELETE')} ${eventPath}`);
            }
            else if (event.kind === 'rename') {
                record.loggingQueue.push(`${chalk.blue('RENAME')} ${eventPath} => ${event.to}`);
            }
        };
    });
}
function runSchematic(host, root, workflow, logger, opts, schematic, printDryRunMessage = true, recorder = null) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const record = { loggingQueue: [], error: false };
        workflow.reporter.subscribe(recorder || (yield createRecorder(host, record, logger)));
        try {
            yield workflow
                .execute({
                collection: opts.collectionName,
                schematic: opts.generatorName,
                options: opts.generatorOptions,
                debug: opts.debug,
                logger,
            })
                .toPromise();
        }
        catch (e) {
            console.log(e);
            throw e;
        }
        if (!record.error) {
            record.loggingQueue.forEach((log) => logger.info(log));
        }
        if (opts.dryRun && printDryRunMessage) {
            logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
        }
        return { status: 0, loggingQueue: record.loggingQueue };
    });
}
class NxScopedHost extends core_1.virtualFs.ScopedHost {
    constructor(root) {
        super(new node_1.NodeJsSyncHost(), root);
    }
    read(path) {
        return this.context(path).pipe(operators_1.switchMap((r) => {
            if (r.isWorkspaceConfig) {
                if (r.isNewFormat) {
                    return super.read(r.actualConfigFileName).pipe(operators_1.map((r) => {
                        try {
                            const w = JSON.parse(Buffer.from(r).toString());
                            const formatted = workspace_1.toOldFormatOrNull(w);
                            return formatted
                                ? Buffer.from(JSON.stringify(formatted, null, 2))
                                : r;
                        }
                        catch (e) {
                            return r;
                        }
                    }));
                }
                else {
                    return super.read(r.actualConfigFileName);
                }
            }
            else {
                return super.read(path);
            }
        }));
    }
    write(path, content) {
        return this.context(path).pipe(operators_1.switchMap((r) => {
            if (r.isWorkspaceConfig) {
                if (r.isNewFormat) {
                    try {
                        const w = JSON.parse(Buffer.from(content).toString());
                        const formatted = workspace_1.toNewFormatOrNull(w);
                        if (formatted) {
                            return super.write(r.actualConfigFileName, Buffer.from(JSON.stringify(formatted, null, 2)));
                        }
                        else {
                            return super.write(r.actualConfigFileName, content);
                        }
                    }
                    catch (e) {
                        return super.write(r.actualConfigFileName, content);
                    }
                }
                else {
                    return super.write(r.actualConfigFileName, content);
                }
            }
            else {
                return super.write(path, content);
            }
        }));
    }
    isFile(path) {
        return this.context(path).pipe(operators_1.switchMap((r) => {
            if (r.isWorkspaceConfig) {
                return super.isFile(r.actualConfigFileName);
            }
            else {
                return super.isFile(path);
            }
        }));
    }
    exists(path) {
        return this.context(path).pipe(operators_1.switchMap((r) => {
            if (r.isWorkspaceConfig) {
                return super.exists(r.actualConfigFileName);
            }
            else {
                return super.exists(path);
            }
        }));
    }
    workspaceConfigName() {
        return super
            .exists('/angular.json')
            .pipe(operators_1.map((hasAngularJson) => hasAngularJson ? 'angular.json' : 'workspace.json'))
            .toPromise();
    }
    context(path) {
        if (isWorkspaceConfigPath(path)) {
            return super.exists('/angular.json').pipe(operators_1.switchMap((isAngularJson) => {
                const actualConfigFileName = isAngularJson
                    ? '/angular.json'
                    : '/workspace.json';
                return super.read(actualConfigFileName).pipe(operators_1.map((r) => {
                    try {
                        const w = JSON.parse(Buffer.from(r).toString());
                        return {
                            isWorkspaceConfig: true,
                            actualConfigFileName,
                            isNewFormat: w.version === 2,
                        };
                    }
                    catch (e) {
                        return {
                            isWorkspaceConfig: true,
                            actualConfigFileName,
                            isNewFormat: false,
                        };
                    }
                }));
            }));
        }
        else {
            return rxjs_1.of({
                isWorkspaceConfig: false,
                actualConfigFileName: null,
                isNewFormat: false,
            });
        }
    }
}
exports.NxScopedHost = NxScopedHost;
/**
 * This host contains the workaround needed to run Angular migrations
 */
class NxScopedHostForMigrations extends NxScopedHost {
    constructor(root) {
        super(root);
    }
    read(path) {
        if (isWorkspaceConfigPath(path)) {
            return super.read(path).pipe(operators_1.map(processConfigWhenReading));
        }
        else {
            return super.read(path);
        }
    }
    write(path, content) {
        if (isWorkspaceConfigPath(path)) {
            return super.write(path, processConfigWhenWriting(content));
        }
        else {
            return super.write(path, content);
        }
    }
}
exports.NxScopedHostForMigrations = NxScopedHostForMigrations;
class NxScopeHostUsedForWrappedSchematics extends NxScopedHost {
    constructor(root, host) {
        super(root);
        this.host = host;
    }
    read(path) {
        if (isWorkspaceConfigPath(path)) {
            const match = findWorkspaceConfigFileChange(this.host);
            // no match, default to existing behavior
            if (!match) {
                return super.read(path);
            }
            // we try to format it, if it changes, return it, otherwise return the original change
            try {
                const w = JSON.parse(Buffer.from(match.content).toString());
                const formatted = workspace_1.toOldFormatOrNull(w);
                return rxjs_1.of(formatted
                    ? Buffer.from(JSON.stringify(formatted, null, 2))
                    : Buffer.from(match.content));
            }
            catch (e) {
                return super.read(path);
            }
        }
        else {
            // found a matching change in the host
            const match = findMatchingFileChange(this.host, path);
            return match ? rxjs_1.of(Buffer.from(match.content)) : super.read(path);
        }
    }
    exists(path) {
        if (isWorkspaceConfigPath(path)) {
            return findWorkspaceConfigFileChange(this.host)
                ? rxjs_1.of(true)
                : super.exists(path);
        }
        else {
            return findMatchingFileChange(this.host, path)
                ? rxjs_1.of(true)
                : super.exists(path);
        }
    }
    isFile(path) {
        if (isWorkspaceConfigPath(path)) {
            return findWorkspaceConfigFileChange(this.host)
                ? rxjs_1.of(true)
                : super.isFile(path);
        }
        else {
            return findMatchingFileChange(this.host, path)
                ? rxjs_1.of(true)
                : super.isFile(path);
        }
    }
}
exports.NxScopeHostUsedForWrappedSchematics = NxScopeHostUsedForWrappedSchematics;
function findWorkspaceConfigFileChange(host) {
    return host
        .listChanges()
        .find((f) => f.path == 'workspace.json' || f.path == 'angular.json');
}
function findMatchingFileChange(host, path) {
    const targetPath = path.startsWith('/') ? path.substring(1) : path.toString;
    return host
        .listChanges()
        .find((f) => f.path == targetPath.toString() && f.type !== 'DELETE');
}
function isWorkspaceConfigPath(p) {
    return (p === 'angular.json' ||
        p === '/angular.json' ||
        p === 'workspace.json' ||
        p === '/workspace.json');
}
function processConfigWhenReading(content) {
    try {
        const json = JSON.parse(Buffer.from(content).toString());
        Object.values(json.projects).forEach((p) => {
            try {
                Object.values(p.architect || p.targets).forEach((e) => {
                    if ((e.builder === '@nrwl/jest:jest' ||
                        e.executor === '@nrwl/jest:jest') &&
                        !e.options.tsConfig) {
                        e.options.tsConfig = `${p.root}/tsconfig.spec.json`;
                    }
                });
            }
            catch (e) { }
        });
        return Buffer.from(JSON.stringify(json, null, 2));
    }
    catch (e) {
        return content;
    }
}
function processConfigWhenWriting(content) {
    try {
        const json = JSON.parse(Buffer.from(content).toString());
        Object.values(json.projects).forEach((p) => {
            try {
                Object.values(p.architect || p.targets).forEach((e) => {
                    if ((e.builder === '@nrwl/jest:jest' ||
                        e.executor === '@nrwl/jest:jest') &&
                        e.options.tsConfig) {
                        delete e.options.tsConfig;
                    }
                });
            }
            catch (e) { }
        });
        return Buffer.from(JSON.stringify(json, null, 2));
    }
    catch (e) {
        return content;
    }
}
function generate(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const workflow = createWorkflow(fsHost, root, opts);
        const collection = getCollection(workflow, opts.collectionName);
        const schematic = collection.createSchematic(opts.generatorName, true);
        return (yield runSchematic(fsHost, root, workflow, logger, Object.assign(Object.assign({}, opts), { generatorName: schematic.description.name }), schematic)).status;
    });
}
exports.generate = generate;
function runMigration(root, collection, schematic, isVerbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const NodeModulesEngineHost = require('@angular-devkit/schematics/tools')
            .NodeModulesEngineHost;
        class MigrationEngineHost extends NodeModulesEngineHost {
            constructor(logger) {
                super();
                this.nodeInstallLogPrinted = false;
                // Overwrite the original CLI node package executor with a new one that does basically nothing
                // since nx migrate doesn't do npm installs by itself
                // (https://github.com/angular/angular-cli/blob/5df776780deadb6be5048b3ab006a5d3383650dc/packages/angular_devkit/schematics/tools/workflow/node-workflow.ts#L41)
                this.registerTaskExecutor({
                    name: require('@angular-devkit/schematics/tasks/package-manager/options')
                        .NodePackageName,
                    create: () => Promise.resolve(() => {
                        return new Promise((res) => {
                            if (!this.nodeInstallLogPrinted) {
                                logger.warn(`An installation of node_modules has been required. Make sure to run it after the migration`);
                                this.nodeInstallLogPrinted = true;
                            }
                            res();
                        });
                    }),
                });
                this.registerTaskExecutor(require('@angular-devkit/schematics/tasks/node').BuiltinTaskExecutor
                    .RunSchematic);
            }
            _resolveCollectionPath(name) {
                let collectionPath = undefined;
                if (name.startsWith('.') || name.startsWith('/')) {
                    name = path_1.resolve(name);
                }
                if (path_1.extname(name)) {
                    collectionPath = require.resolve(name);
                }
                else {
                    let packageJsonPath;
                    try {
                        packageJsonPath = require.resolve(path.join(name, 'package.json'), {
                            paths: [process.cwd()],
                        });
                    }
                    catch (e) {
                        // workaround for a bug in node 12
                        packageJsonPath = require.resolve(path.join(process.cwd(), name, 'package.json'));
                    }
                    // eslint-disable-next-line @typescript-eslint/no-var-requires
                    const packageJson = require(packageJsonPath);
                    let pkgJsonSchematics = packageJson['nx-migrations'];
                    if (!pkgJsonSchematics) {
                        pkgJsonSchematics = packageJson['ng-update'];
                        if (!pkgJsonSchematics) {
                            throw new Error(`Could not find migrations in package: "${name}"`);
                        }
                    }
                    if (typeof pkgJsonSchematics != 'string') {
                        pkgJsonSchematics = pkgJsonSchematics.migrations;
                    }
                    collectionPath = path_1.resolve(path_1.dirname(packageJsonPath), pkgJsonSchematics);
                }
                try {
                    if (collectionPath) {
                        JSON.parse(stripJsonComments(fs_1.readFileSync(collectionPath).toString()));
                        return collectionPath;
                    }
                }
                catch (e) {
                    throw new Error(`Invalid migration file in package: "${name}"`);
                }
                throw new Error(`Collection cannot be resolved: "${name}"`);
            }
        }
        const { BaseWorkflow } = require('@angular-devkit/schematics/src/workflow');
        class MigrationsWorkflow extends BaseWorkflow {
            constructor(host, logger) {
                super({
                    host,
                    engineHost: new MigrationEngineHost(logger),
                    force: true,
                    dryRun: false,
                });
            }
        }
        const logger = exports.getLogger(isVerbose);
        const host = new NxScopedHostForMigrations(core_1.normalize(root));
        const workflow = new MigrationsWorkflow(host, logger);
        return workflow
            .execute({
            collection,
            schematic,
            options: {},
            debug: false,
            logger: logger,
        })
            .toPromise();
    });
}
exports.runMigration = runMigration;
function convertEventTypeToHandleMultipleConfigNames(host, eventPath, content) {
    const actualConfigName = host.exists('/workspace.json')
        ? 'workspace.json'
        : 'angular.json';
    const isWorkspaceConfig = eventPath === 'angular.json' || eventPath === 'workspace.json';
    if (isWorkspaceConfig) {
        let isNewFormat = true;
        try {
            isNewFormat =
                JSON.parse(host.read(actualConfigName).toString()).version === 2;
        }
        catch (e) { }
        if (content && isNewFormat) {
            const formatted = workspace_1.toNewFormatOrNull(JSON.parse(content.toString()));
            if (formatted) {
                return {
                    eventPath: actualConfigName,
                    content: Buffer.from(JSON.stringify(formatted, null, 2)),
                };
            }
            else {
                return { eventPath: actualConfigName, content };
            }
        }
        else {
            return { eventPath: actualConfigName, content };
        }
    }
    else {
        return { eventPath, content };
    }
}
let collectionResolutionOverrides = null;
let mockedSchematics = null;
/**
 * By default, Angular Devkit schematic collections will be resolved using the Node resolution.
 * This doesn't work if you are testing schematics that refer to other schematics in the
 * same repo.
 *
 * This function can can be used to override the resolution behaviour.
 *
 * Example:
 *
 * ```
 *   overrideCollectionResolutionForTesting({
 *     '@nrwl/workspace': path.join(__dirname, '../../../../workspace/collection.json'),
 *     '@nrwl/angular': path.join(__dirname, '../../../../angular/collection.json'),
 *     '@nrwl/linter': path.join(__dirname, '../../../../linter/collection.json')
 *   });
 *
 * ```
 */
function overrideCollectionResolutionForTesting(collections) {
    collectionResolutionOverrides = collections;
}
exports.overrideCollectionResolutionForTesting = overrideCollectionResolutionForTesting;
/**
 * If you have an Nx Devkit generator invoking the wrapped Angular Devkit schematic,
 * and you don't want the Angular Devkit schematic to run, you can mock it up using this function.
 *
 * Unfortunately, there are some edge cases in the Nx-Angular devkit integration that
 * can be seen in the unit tests context. This function is useful for handling that as well.
 *
 * In this case, you can mock it up.
 *
 * Example:
 *
 * ```
 *   mockSchematicsForTesting({
 *     'mycollection:myschematic': (tree, params) => {
 *        tree.write('README.md');
 *     }
 *   });
 *
 * ```
 */
function mockSchematicsForTesting(schematics) {
    mockedSchematics = schematics;
}
exports.mockSchematicsForTesting = mockSchematicsForTesting;
function wrapAngularDevkitSchematic(collectionName, generatorName) {
    return (host, generatorOptions) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (mockedSchematics &&
            mockedSchematics[`${collectionName}:${generatorName}`]) {
            return yield mockedSchematics[`${collectionName}:${generatorName}`](host, generatorOptions);
        }
        const emptyLogger = {
            log: (e) => { },
            info: (e) => { },
            warn: (e) => { },
            debug: () => { },
            error: (e) => { },
            fatal: (e) => { },
        };
        emptyLogger.createChild = () => emptyLogger;
        const recorder = (event) => {
            let eventPath = event.path.startsWith('/')
                ? event.path.substr(1)
                : event.path;
            const r = convertEventTypeToHandleMultipleConfigNames(host, eventPath, event.content);
            if (event.kind === 'error') {
            }
            else if (event.kind === 'update') {
                host.write(r.eventPath, r.content);
            }
            else if (event.kind === 'create') {
                host.write(r.eventPath, r.content);
            }
            else if (event.kind === 'delete') {
                host.delete(r.eventPath);
            }
            else if (event.kind === 'rename') {
                host.rename(r.eventPath, event.to);
            }
        };
        const fsHost = new NxScopeHostUsedForWrappedSchematics(core_1.normalize(host.root), host);
        const options = {
            generatorOptions: Object.assign(Object.assign({}, generatorOptions), { _: [] }),
            dryRun: true,
            interactive: false,
            help: false,
            debug: false,
            collectionName,
            generatorName,
            force: false,
            defaults: false,
        };
        const workflow = createWorkflow(fsHost, host.root, options);
        // used for testing
        if (collectionResolutionOverrides) {
            const r = workflow.engineHost.resolve;
            workflow.engineHost.resolve = (collection, b, c) => {
                if (collectionResolutionOverrides[collection]) {
                    return collectionResolutionOverrides[collection];
                }
                else {
                    return r.apply(workflow.engineHost, [collection, b, c]);
                }
            };
        }
        const collection = getCollection(workflow, collectionName);
        const schematic = collection.createSchematic(generatorName, true);
        const res = yield runSchematic(fsHost, host.root, workflow, emptyLogger, options, schematic, false, recorder);
        if (res.status !== 0) {
            throw new Error(res.loggingQueue.join('\n'));
        }
    });
}
exports.wrapAngularDevkitSchematic = wrapAngularDevkitSchematic;
function invokeNew(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const workflow = createWorkflow(fsHost, root, opts);
        const collection = getCollection(workflow, opts.collectionName);
        const schematic = collection.createSchematic('new', true);
        return (yield runSchematic(fsHost, root, workflow, logger, Object.assign(Object.assign({}, opts), { generatorName: schematic.description.name }), schematic)).status;
    });
}
exports.invokeNew = invokeNew;
let logger;
exports.getLogger = (isVerbose = false) => {
    if (!logger) {
        logger = node_1.createConsoleLogger(isVerbose, process.stdout, process.stderr, {
            warn: (s) => chalk.bold(chalk.yellow(s)),
            error: (s) => {
                if (s.startsWith('NX ')) {
                    return `\n${logger_1.NX_ERROR} ${chalk.bold(chalk.red(s.substr(3)))}\n`;
                }
                return chalk.bold(chalk.red(s));
            },
            info: (s) => {
                if (s.startsWith('NX ')) {
                    return `\n${logger_1.NX_PREFIX} ${chalk.bold(s.substr(3))}\n`;
                }
                return chalk.white(s);
            },
        });
    }
    return logger;
};
//# sourceMappingURL=ngcli-adapter.js.map