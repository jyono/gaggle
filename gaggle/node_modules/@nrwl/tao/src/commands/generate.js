"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = exports.taoNew = exports.flushChanges = exports.printGenHelp = void 0;
const tslib_1 = require("tslib");
const minimist = require("minimist");
const params_1 = require("../shared/params");
const print_help_1 = require("../shared/print-help");
const workspace_1 = require("../shared/workspace");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const tree_1 = require("../shared/tree");
const logger_1 = require("../shared/logger");
const chalk = require('chalk');
function throwInvalidInvocation() {
    throw new Error(`Specify the generator name (e.g., nx generate @nrwl/workspace:library)`);
}
function parseGenerateOpts(args, mode, defaultCollection) {
    const generatorOptions = params_1.convertToCamelCase(minimist(args, {
        boolean: ['help', 'dryRun', 'debug', 'force', 'interactive', 'defaults'],
        alias: {
            dryRun: 'dry-run',
            d: 'dryRun',
        },
        default: {
            debug: false,
            dryRun: false,
            interactive: true,
        },
    }));
    // TODO: vsavkin remove defaults in Nx 13
    if (generatorOptions.defaults) {
        logger_1.logger.warn(`Use --no-interactive instead of --defaults. The --defaults option will be removed in Nx 13.`);
        generatorOptions.interactive = false;
    }
    let collectionName = null;
    let generatorName = null;
    if (mode === 'generate') {
        if (!generatorOptions['_'] ||
            generatorOptions['_'].length === 0) {
            throwInvalidInvocation();
        }
        const generatorDescriptor = generatorOptions['_'].shift();
        const separatorIndex = generatorDescriptor.lastIndexOf(':');
        if (separatorIndex > 0) {
            collectionName = generatorDescriptor.substr(0, separatorIndex);
            generatorName = generatorDescriptor.substr(separatorIndex + 1);
        }
        else {
            collectionName = defaultCollection;
            generatorName = generatorDescriptor;
        }
    }
    else {
        collectionName = generatorOptions.collection;
        generatorName = 'new';
    }
    if (!collectionName) {
        throwInvalidInvocation();
    }
    const res = {
        collectionName,
        generatorName,
        generatorOptions,
        help: generatorOptions.help,
        debug: generatorOptions.debug,
        dryRun: generatorOptions.dryRun,
        force: generatorOptions.force,
        interactive: generatorOptions.interactive,
        defaults: generatorOptions.defaults,
    };
    delete generatorOptions.debug;
    delete generatorOptions.d;
    delete generatorOptions.dryRun;
    delete generatorOptions.force;
    delete generatorOptions.interactive;
    delete generatorOptions.defaults;
    delete generatorOptions.help;
    delete generatorOptions.collection;
    delete generatorOptions['--'];
    return res;
}
function printGenHelp(opts, schema) {
    print_help_1.printHelp(`nx generate ${opts.collectionName}:${opts.generatorName}`, Object.assign(Object.assign({}, schema), { properties: Object.assign(Object.assign({}, schema.properties), { dryRun: {
                type: 'boolean',
                default: false,
                description: `Runs through and reports activity without writing to disk.`,
            } }) }));
}
exports.printGenHelp = printGenHelp;
function readDefaultCollection(workspace) {
    return workspace.cli ? workspace.cli.defaultCollection : null;
}
function flushChanges(root, fileChanges) {
    fileChanges.forEach((f) => {
        const fpath = path.join(root, f.path);
        if (f.type === 'CREATE') {
            fs_extra_1.mkdirpSync(path.dirname(fpath));
            fs_1.writeFileSync(fpath, f.content);
        }
        else if (f.type === 'UPDATE') {
            fs_1.writeFileSync(fpath, f.content);
        }
        else if (f.type === 'DELETE') {
            try {
                const stat = fs_1.statSync(fpath);
                if (stat.isDirectory()) {
                    fs_extra_1.rmdirSync(fpath, { recursive: true });
                }
                else {
                    fs_1.unlinkSync(fpath);
                }
            }
            catch (e) { }
        }
    });
}
exports.flushChanges = flushChanges;
function printChanges(fileChanges) {
    fileChanges.forEach((f) => {
        if (f.type === 'CREATE') {
            console.log(`${chalk.green('CREATE')} ${f.path}`);
        }
        else if (f.type === 'UPDATE') {
            console.log(`${chalk.white('UPDATE')} ${f.path}`);
        }
        else if (f.type === 'DELETE') {
            console.log(`${chalk.yellow('DELETE')} ${f.path}`);
        }
    });
}
function taoNew(cwd, args, isVerbose = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ws = new workspace_1.Workspaces(null);
        return params_1.handleErrors(isVerbose, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const opts = parseGenerateOpts(args, 'new', null);
            const { normalizedGeneratorName, schema, implementationFactory, } = ws.readGenerator(opts.collectionName, opts.generatorName);
            const combinedOpts = yield params_1.combineOptionsForGenerator(opts.generatorOptions, opts.collectionName, normalizedGeneratorName, null, schema, opts.interactive, null, null);
            if (ws.isNxGenerator(opts.collectionName, normalizedGeneratorName)) {
                const host = new tree_1.FsTree(cwd, isVerbose);
                const implementation = implementationFactory();
                const task = yield implementation(host, combinedOpts);
                const changes = host.listChanges();
                printChanges(changes);
                if (!opts.dryRun) {
                    flushChanges(cwd, changes);
                    if (task) {
                        yield task();
                    }
                }
                else {
                    logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
                }
            }
            else {
                return (yield Promise.resolve().then(() => require('./ngcli-adapter'))).generate(cwd, Object.assign(Object.assign({}, opts), { generatorOptions: combinedOpts }), isVerbose);
            }
        }));
    });
}
exports.taoNew = taoNew;
function generate(cwd, root, args, isVerbose = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ws = new workspace_1.Workspaces(root);
        return params_1.handleErrors(isVerbose, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const workspaceDefinition = ws.readWorkspaceConfiguration();
            const opts = parseGenerateOpts(args, 'generate', readDefaultCollection(workspaceDefinition));
            const { normalizedGeneratorName, schema, implementationFactory, } = ws.readGenerator(opts.collectionName, opts.generatorName);
            if (opts.help) {
                printGenHelp(opts, schema);
                return 0;
            }
            const combinedOpts = yield params_1.combineOptionsForGenerator(opts.generatorOptions, opts.collectionName, normalizedGeneratorName, workspaceDefinition, schema, opts.interactive, ws.calculateDefaultProjectName(cwd, workspaceDefinition), ws.relativeCwd(cwd));
            if (ws.isNxGenerator(opts.collectionName, normalizedGeneratorName)) {
                const host = new tree_1.FsTree(root, isVerbose);
                const implementation = implementationFactory();
                const task = yield implementation(host, combinedOpts);
                const changes = host.listChanges();
                printChanges(changes);
                if (!opts.dryRun) {
                    flushChanges(root, changes);
                    if (task) {
                        yield task();
                    }
                }
                else {
                    logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
                }
            }
            else {
                return (yield Promise.resolve().then(() => require('./ngcli-adapter'))).generate(root, Object.assign(Object.assign({}, opts), { generatorOptions: combinedOpts }), isVerbose);
            }
        }));
    });
}
exports.generate = generate;
//# sourceMappingURL=generate.js.map