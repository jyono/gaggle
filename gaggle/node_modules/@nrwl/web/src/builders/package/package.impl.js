"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollupOptions = void 0;
const devkit_1 = require("@nrwl/devkit");
const rollup = require("rollup");
const peerDepsExternal = require("rollup-plugin-peer-deps-external");
const localResolve = require("rollup-plugin-local-resolve");
const plugin_babel_1 = require("@rollup/plugin-babel");
// These use require because the ES import isn't correct.
const resolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const typescript = require('rollup-plugin-typescript2');
const image = require('@rollup/plugin-image');
const json = require('@rollup/plugin-json');
const copy = require('rollup-plugin-copy');
const postcss = require('rollup-plugin-postcss');
const filesize = require('rollup-plugin-filesize');
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("rxjs-for-await");
const autoprefixer = require("autoprefixer");
const fileutils_1 = require("@nrwl/workspace/src/utilities/fileutils");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const normalize_1 = require("../../utils/normalize");
const delete_output_dir_1 = require("../../utils/delete-output-dir");
const run_rollup_1 = require("./run-rollup");
const outputConfigs = [
    { format: 'umd', extension: 'umd' },
    { format: 'esm', extension: 'esm' },
];
const fileExtensions = ['.js', '.jsx', '.ts', '.tsx'];
function run(rawOptions, context) {
    const project = context.workspace.projects[context.projectName];
    const sourceRoot = project.sourceRoot;
    const projGraph = project_graph_1.createProjectGraph();
    const { target, dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projGraph, context.root, context.projectName, context.targetName, context.configurationName);
    if (!buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies)) {
        throw new Error();
    }
    const options = normalize_1.normalizePackageOptions(rawOptions, context.root, sourceRoot);
    const packageJson = fileutils_1.readJsonFile(options.project);
    const rollupOptions = createRollupOptions(options, dependencies, context, packageJson, sourceRoot);
    if (options.watch) {
        const watcher = rollup.watch(rollupOptions);
        return rxjs_for_await_1.eachValueFrom(new rxjs_1.Observable((obs) => {
            watcher.on('event', (data) => {
                if (data.code === 'START') {
                    devkit_1.logger.info(`Bundling ${context.projectName}...`);
                }
                else if (data.code === 'END') {
                    updatePackageJson(options, context, target, dependencies, packageJson);
                    devkit_1.logger.info('Bundle complete. Watching for file changes...');
                    obs.next({ success: true });
                }
                else if (data.code === 'ERROR') {
                    devkit_1.logger.error(`Error during bundle: ${data.error.message}`);
                    obs.next({ success: false });
                }
            });
            // Teardown logic. Close watcher when unsubscribed.
            return () => watcher.close();
        }));
    }
    else {
        devkit_1.logger.info(`Bundling ${context.projectName}...`);
        // Delete output path before bundling
        if (options.deleteOutputPath) {
            delete_output_dir_1.deleteOutputDir(context.root, options.outputPath);
        }
        return rxjs_1.from(rollupOptions)
            .pipe(operators_1.concatMap((opts) => run_rollup_1.runRollup(opts).pipe(operators_1.catchError((e) => {
            devkit_1.logger.error(`Error during bundle: ${e}`);
            return rxjs_1.of({ success: false });
        }), operators_1.last(), operators_1.tap({
            next: (result) => {
                if (result.success) {
                    updatePackageJson(options, context, target, dependencies, packageJson);
                    devkit_1.logger.info(`Bundle complete: ${context.projectName}`);
                }
                else {
                    devkit_1.logger.error(`Bundle failed: ${context.projectName}`);
                }
            },
        }))))
            .toPromise();
    }
}
exports.default = run;
// -----------------------------------------------------------------------------
function createRollupOptions(options, dependencies, context, packageJson, sourceRoot) {
    return outputConfigs.map((config) => {
        const compilerOptionPaths = buildable_libs_utils_1.computeCompilerOptionsPaths(options.tsConfig, dependencies);
        const plugins = [
            copy({
                targets: convertCopyAssetsToRollupOptions(options.outputPath, options.assets),
            }),
            image(),
            typescript({
                check: true,
                tsconfig: options.tsConfig,
                tsconfigOverride: {
                    compilerOptions: {
                        rootDir: options.entryRoot,
                        allowJs: false,
                        declaration: true,
                        paths: compilerOptionPaths,
                        target: config.format === 'esm' ? undefined : 'es5',
                    },
                },
            }),
            peerDepsExternal({
                packageJsonPath: options.project,
            }),
            postcss({
                inject: true,
                extract: options.extractCss,
                autoModules: true,
                plugins: [autoprefixer],
            }),
            localResolve(),
            resolve({
                preferBuiltins: true,
                extensions: fileExtensions,
            }),
            plugin_babel_1.getBabelInputPlugin({
                cwd: path_1.join(context.root, sourceRoot),
                rootMode: 'upward',
                babelrc: true,
                extensions: fileExtensions,
                babelHelpers: 'bundled',
                exclude: /node_modules/,
                plugins: [
                    config.format === 'esm'
                        ? undefined
                        : require.resolve('babel-plugin-transform-async-to-promises'),
                ].filter(Boolean),
            }),
            commonjs(),
            filesize(),
            json(),
        ];
        const globals = options.globals
            ? options.globals.reduce((acc, item) => {
                acc[item.moduleId] = item.global;
                return acc;
            }, {})
            : {};
        const externalPackages = dependencies
            .map((d) => d.name)
            .concat(options.external || [])
            .concat(Object.keys(packageJson.dependencies || {}));
        const rollupConfig = {
            input: options.entryFile,
            output: {
                globals,
                format: config.format,
                file: `${options.outputPath}/${context.projectName}.${config.extension}.js`,
                name: options.umdName || devkit_1.names(context.projectName).className,
            },
            external: (id) => externalPackages.includes(id),
            plugins,
        };
        return options.rollupConfig
            ? require(options.rollupConfig)(rollupConfig, options)
            : rollupConfig;
    });
}
exports.createRollupOptions = createRollupOptions;
function updatePackageJson(options, context, target, dependencies, packageJson) {
    const entryFileTmpl = `./${context.projectName}.<%= extension %>.js`;
    const typingsFile = path_1.relative(options.entryRoot, options.entryFile).replace(/\.[jt]sx?$/, '.d.ts');
    packageJson.main = entryFileTmpl.replace('<%= extension %>', 'umd');
    packageJson.module = entryFileTmpl.replace('<%= extension %>', 'esm');
    packageJson.typings = `./${typingsFile}`;
    fileutils_1.writeJsonFile(`${options.outputPath}/package.json`, packageJson);
    if (dependencies.length > 0 &&
        options.updateBuildableProjectDepsInPackageJson) {
        buildable_libs_utils_1.updateBuildableProjectPackageJsonDependencies(context.root, context.projectName, context.targetName, context.configurationName, target, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
}
function convertCopyAssetsToRollupOptions(outputPath, assets) {
    return assets
        ? assets.map((a) => ({
            src: path_1.join(a.input, a.glob).replace(/\\/g, '/'),
            dest: path_1.join(outputPath, a.output).replace(/\\/g, '/'),
        }))
        : undefined;
}
//# sourceMappingURL=package.impl.js.map