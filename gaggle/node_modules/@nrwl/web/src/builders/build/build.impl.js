"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const tslib_1 = require("tslib");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("rxjs-for-await");
const child_process_1 = require("child_process");
const semver_1 = require("semver");
const path_1 = require("path");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const run_webpack_1 = require("@nrwl/workspace/src/utilities/run-webpack");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const write_index_html_1 = require("../../utils/third-party/cli-files/utilities/index-file/write-index-html");
const build_browser_features_1 = require("../../utils/third-party/utils/build-browser-features");
const normalize_1 = require("../../utils/normalize");
const web_config_1 = require("../../utils/web.config");
const delete_output_dir_1 = require("../../utils/delete-output-dir");
function getWebpackConfigs(options, context) {
    const metadata = context.workspace.projects[context.projectName];
    const sourceRoot = metadata.sourceRoot;
    const projectRoot = metadata.root;
    options = normalize_1.normalizeWebBuildOptions(options, context.root, sourceRoot);
    const isScriptOptimizeOn = typeof options.optimization === 'boolean'
        ? options.optimization
        : options.optimization && options.optimization.scripts
            ? options.optimization.scripts
            : false;
    const tsConfig = typescript_1.readTsConfig(options.tsConfig);
    const scriptTarget = tsConfig.options.target;
    const buildBrowserFeatures = new build_browser_features_1.BuildBrowserFeatures(projectRoot, scriptTarget);
    return [
        // ESM build for modern browsers.
        web_config_1.getWebConfig(context.root, sourceRoot, options, true, isScriptOptimizeOn, context.configurationName),
        // ES5 build for legacy browsers.
        isScriptOptimizeOn && buildBrowserFeatures.isDifferentialLoadingNeeded()
            ? web_config_1.getWebConfig(context.root, sourceRoot, options, false, isScriptOptimizeOn, context.configurationName)
            : undefined,
    ]
        .filter(Boolean)
        .map((config) => options.webpackConfig
        ? require(options.webpackConfig)(config, {
            options,
            configuration: context.configurationName,
        })
        : config);
}
function run(options, context) {
    // Node versions 12.2-12.8 has a bug where prod builds will hang for 2-3 minutes
    // after the program exits.
    const nodeVersion = child_process_1.execSync(`node --version`).toString('utf-8').trim();
    const supportedRange = new semver_1.Range('10 || >=12.9');
    if (!semver_1.satisfies(nodeVersion, supportedRange)) {
        throw new Error(`Node version ${nodeVersion} is not supported. Supported range is "${supportedRange.raw}".`);
    }
    const metadata = context.workspace.projects[context.projectName];
    if (!options.buildLibsFromSource && context.targetName) {
        const projGraph = project_graph_1.createProjectGraph();
        const { dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projGraph, context.root, context.projectName, context.targetName, context.configurationName);
        options.tsConfig = buildable_libs_utils_1.createTmpTsConfig(path_1.join(context.root, options.tsConfig), context.root, metadata.root, dependencies);
        if (!buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies)) {
            throw new Error();
        }
    }
    // Delete output path before bundling
    if (options.deleteOutputPath) {
        delete_output_dir_1.deleteOutputDir(context.root, options.outputPath);
    }
    const configs = getWebpackConfigs(options, context);
    return rxjs_for_await_1.eachValueFrom(rxjs_1.from(configs).pipe(
    // Run build sequentially and bail when first one fails.
    operators_1.mergeScan((acc, config) => {
        if (!acc.hasErrors()) {
            return run_webpack_1.runWebpack(config).pipe(operators_1.tap((stats) => {
                console.info(stats.toString(config.stats));
            }));
        }
        else {
            return rxjs_1.of();
        }
    }, { hasErrors: () => false }, 1), 
    // Collect build results as an array.
    operators_1.bufferCount(configs.length), operators_1.switchMap(([result1, result2]) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const success = result1 && !result1.hasErrors() && (!result2 || !result2.hasErrors());
        const emittedFiles1 = run_webpack_1.getEmittedFiles(result1);
        const emittedFiles2 = result2 ? run_webpack_1.getEmittedFiles(result2) : [];
        if (options.optimization) {
            yield write_index_html_1.writeIndexHtml({
                crossOrigin: options.crossOrigin,
                outputPath: path_1.join(options.outputPath, path_1.basename(options.index)),
                indexPath: path_1.join(context.root, options.index),
                files: emittedFiles1.filter((x) => x.extension === '.css'),
                noModuleFiles: emittedFiles2,
                moduleFiles: emittedFiles1,
                baseHref: options.baseHref,
                deployUrl: options.deployUrl,
                scripts: options.scripts,
                styles: options.styles,
            });
        }
        return { success, emittedFiles: [...emittedFiles1, ...emittedFiles2] };
    }))));
}
exports.run = run;
exports.default = run;
//# sourceMappingURL=build.impl.js.map