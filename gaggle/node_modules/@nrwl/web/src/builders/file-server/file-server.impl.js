"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_watch_1 = require("node-watch");
const child_process_1 = require("child_process");
const ignore_1 = require("ignore");
const fs_extra_1 = require("fs-extra");
function getHttpServerArgs(opts) {
    const args = [];
    if (opts.port) {
        args.push(`-p ${opts.port}`);
    }
    if (opts.host) {
        args.push(`-a ${opts.host}`);
    }
    if (opts.ssl) {
        args.push(`-S`);
    }
    if (opts.sslCert) {
        args.push(`-C ${opts.sslCert}`);
    }
    if (opts.sslKey) {
        args.push(`-K ${opts.sslKey}`);
    }
    if (opts.proxyUrl) {
        args.push(`-P ${opts.proxyUrl}`);
    }
    return args;
}
function getBuildTargetCommand(opts) {
    const cmd = [`npx nx run ${opts.buildTarget}`];
    if (opts.withDeps) {
        cmd.push(`--with-deps`);
    }
    if (opts.parallel) {
        cmd.push(`--parallel`);
    }
    if (opts.maxParallel) {
        cmd.push(`--maxParallel=${opts.maxParallel}`);
    }
    return cmd.join(' ');
}
function getBuildTargetOutputPath(opts, context) {
    let buildOpts;
    try {
        const [project, target, config] = opts.buildTarget.split(':');
        const buildTarget = context.workspace.projects[project].targets[target];
        buildOpts = config
            ? Object.assign(Object.assign({}, buildTarget.options), buildTarget.configurations[config]) : buildTarget.options;
    }
    catch (e) {
        throw new Error(`Invalid buildTarget: ${opts.buildTarget}`);
    }
    // TODO: vsavkin we should also check outputs
    const outputPath = buildOpts.outputPath;
    if (!outputPath) {
        throw new Error(`Invalid buildTarget: ${opts.buildTarget}. The target must contain outputPath property.`);
    }
    return outputPath;
}
function getIgnoredGlobs(root) {
    const ig = ignore_1.default();
    try {
        ig.add(fs_extra_1.readFileSync(`${root}/.gitignore`).toString());
    }
    catch (e) { }
    try {
        ig.add(fs_extra_1.readFileSync(`${root}/.nxignore`).toString());
    }
    catch (e) { }
    return ig;
}
function default_1(opts, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let changed = true;
        let running = false;
        const fileFilter = getIgnoredGlobs(context.root).createFilter();
        // TODO: vsavkin create a transitive closure of all deps and watch src of all the packages in the closure
        node_watch_1.default('libs', { recursive: true, filter: fileFilter }, () => {
            changed = true;
            run();
        });
        node_watch_1.default('apps', { recursive: true, filter: fileFilter }, () => {
            changed = true;
            run();
        });
        function run() {
            if (changed && !running) {
                changed = false;
                running = true;
                try {
                    child_process_1.execSync(getBuildTargetCommand(opts), {
                        stdio: [0, 1, 2],
                    });
                }
                catch (e) { }
                running = false;
                setTimeout(() => run(), 1000);
            }
        }
        const outputPath = getBuildTargetOutputPath(opts, context);
        const args = getHttpServerArgs(opts);
        run();
        const serve = child_process_1.exec(`npx http-server ${outputPath} ${args.join(' ')}`, {
            cwd: context.root,
        });
        serve.stdout.on('data', (chunk) => {
            if (chunk.toString().indexOf('GET') === -1) {
                process.stdout.write(chunk);
            }
        });
        serve.stderr.on('data', (chunk) => {
            process.stderr.write(chunk);
        });
        return new Promise((res) => {
            serve.on('exit', (code) => {
                if (code == 0) {
                    res({ success: true });
                }
                else {
                    res({ success: false });
                }
            });
        });
    });
}
exports.default = default_1;
//# sourceMappingURL=file-server.impl.js.map