"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jestConfigObject = exports.jestConfigObjectAst = exports.removeProperty = exports.addOrUpdateProperty = exports.getJsonObject = void 0;
const ts = require("typescript");
const typescript_1 = require("typescript");
const devkit_1 = require("@nrwl/devkit");
const stripJsonComments = require("strip-json-comments");
function makeTextToInsert(value, precedingCommaNeeded) {
    return `${precedingCommaNeeded ? ',' : ''}${value}`;
}
function findPropertyAssignment(object, propertyName) {
    return object.properties.find((prop) => {
        const propNameText = prop.name.getText();
        if (propNameText.match(/^["'].+["']$/g)) {
            return JSON.parse(propNameText.replace(/'/g, '"')) === propertyName;
        }
        return propNameText === propertyName;
    });
}
function getJsonObject(object) {
    const value = stripJsonComments(object);
    // react babel-jest has __dirname in the config.
    // Put a temp variable in the anon function so that it doesnt fail.
    // Migration script has a catch handler to give instructions on how to update the jest config if this fails.
    return Function(`
  "use strict";
  let __dirname = '';
  return (${value});
 `)();
}
exports.getJsonObject = getJsonObject;
function addOrUpdateProperty(tree, object, properties, value, path) {
    const propertyName = properties.shift();
    const propertyAssignment = findPropertyAssignment(object, propertyName);
    const originalContents = tree.read(path).toString();
    if (propertyAssignment) {
        if (propertyAssignment.initializer.kind === ts.SyntaxKind.StringLiteral ||
            propertyAssignment.initializer.kind === ts.SyntaxKind.NumericLiteral ||
            propertyAssignment.initializer.kind === ts.SyntaxKind.FalseKeyword ||
            propertyAssignment.initializer.kind === ts.SyntaxKind.TrueKeyword) {
            const updatedContents = devkit_1.applyChangesToString(originalContents, [
                {
                    type: devkit_1.ChangeType.Delete,
                    start: propertyAssignment.initializer.pos,
                    length: propertyAssignment.initializer.getFullText().length,
                },
                {
                    type: devkit_1.ChangeType.Insert,
                    index: propertyAssignment.initializer.pos,
                    text: value,
                },
            ]);
            tree.write(path, updatedContents);
            return;
        }
        if (propertyAssignment.initializer.kind ===
            ts.SyntaxKind.ArrayLiteralExpression) {
            const arrayLiteral = propertyAssignment.initializer;
            if (arrayLiteral.elements.some((element) => {
                return element.getText().replace(/'/g, '"') === value;
            })) {
                return [];
            }
            if (arrayLiteral.elements.length === 0) {
                const updatedContents = devkit_1.applyChangesToString(originalContents, [
                    {
                        type: devkit_1.ChangeType.Insert,
                        index: arrayLiteral.elements.end,
                        text: value,
                    },
                ]);
                tree.write(path, updatedContents);
                return;
            }
            else {
                const text = makeTextToInsert(value, arrayLiteral.elements.length !== 0 &&
                    !arrayLiteral.elements.hasTrailingComma);
                const updatedContents = devkit_1.applyChangesToString(originalContents, [
                    {
                        type: devkit_1.ChangeType.Insert,
                        index: arrayLiteral.elements.end,
                        text,
                    },
                ]);
                tree.write(path, updatedContents);
                return;
            }
        }
        else if (propertyAssignment.initializer.kind ===
            ts.SyntaxKind.ObjectLiteralExpression) {
            return addOrUpdateProperty(tree, propertyAssignment.initializer, properties, value, path);
        }
    }
    else {
        if (propertyName === undefined) {
            throw new Error(`Please use dot delimited paths to update an existing object. Eg. object.property `);
        }
        const text = makeTextToInsert(`${JSON.stringify(propertyName)}: ${value}`, object.properties.length !== 0 && !object.properties.hasTrailingComma);
        const updatedContents = devkit_1.applyChangesToString(originalContents, [
            {
                type: devkit_1.ChangeType.Insert,
                index: object.properties.end,
                text,
            },
        ]);
        tree.write(path, updatedContents);
        return;
    }
}
exports.addOrUpdateProperty = addOrUpdateProperty;
function removeProperty(object, properties) {
    const propertyName = properties.shift();
    const propertyAssignment = findPropertyAssignment(object, propertyName);
    if (propertyAssignment) {
        if (properties.length > 0 &&
            propertyAssignment.initializer.kind ===
                ts.SyntaxKind.ObjectLiteralExpression) {
            return removeProperty(propertyAssignment.initializer, properties);
        }
        return propertyAssignment;
    }
    else {
        return null;
    }
}
exports.removeProperty = removeProperty;
/**
 * Should be used to get the jest config object.
 *
 * @param host
 * @param path
 */
function jestConfigObjectAst(fileContent) {
    const sourceFile = ts.createSourceFile('jest.config.js', fileContent, ts.ScriptTarget.Latest, true);
    const moduleExportsStatement = sourceFile.statements.find((statement) => typescript_1.isExpressionStatement(statement) &&
        typescript_1.isBinaryExpression(statement.expression) &&
        statement.expression.left.getText() === 'module.exports' &&
        statement.expression.operatorToken.kind === typescript_1.SyntaxKind.EqualsToken);
    const moduleExports = moduleExportsStatement
        .expression;
    if (!moduleExports) {
        throw new Error(`
       The provided jest config file does not have the expected 'module.exports' expression. 
       See https://jestjs.io/docs/en/configuration for more details.`);
    }
    if (!ts.isObjectLiteralExpression(moduleExports.right)) {
        throw new Error(`The 'module.exports' expression is not an object literal.`);
    }
    return moduleExports.right;
}
exports.jestConfigObjectAst = jestConfigObjectAst;
/**
 * Returns the jest config object
 * @param host
 * @param path
 */
function jestConfigObject(host, path) {
    const jestConfigAst = jestConfigObjectAst(host.read(path).toString('utf-8'));
    return getJsonObject(jestConfigAst.getText());
}
exports.jestConfigObject = jestConfigObject;
//# sourceMappingURL=functions.js.map