"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptImportLocator = void 0;
const ts = require("typescript");
const path = require("path");
const project_graph_models_1 = require("../project-graph-models");
const strip_source_code_1 = require("../../../utilities/strip-source-code");
class TypeScriptImportLocator {
    constructor(fileRead) {
        this.fileRead = fileRead;
        this.scanner = ts.createScanner(ts.ScriptTarget.Latest, false);
    }
    fromFile(filePath, visitor) {
        const extension = path.extname(filePath);
        if (extension !== '.ts' &&
            extension !== '.tsx' &&
            extension !== '.js' &&
            extension !== '.jsx') {
            return;
        }
        const content = this.fileRead(filePath);
        const strippedContent = strip_source_code_1.stripSourceCode(this.scanner, content);
        if (strippedContent !== '') {
            const tsFile = ts.createSourceFile(filePath, strippedContent, ts.ScriptTarget.Latest, true);
            this.fromNode(filePath, tsFile, visitor);
        }
    }
    fromNode(filePath, node, visitor) {
        if (ts.isImportDeclaration(node) ||
            (ts.isExportDeclaration(node) && node.moduleSpecifier)) {
            if (!this.ignoreStatement(node)) {
                const imp = this.getStringLiteralValue(node.moduleSpecifier);
                visitor(imp, filePath, project_graph_models_1.DependencyType.static);
            }
            return; // stop traversing downwards
        }
        if (ts.isCallExpression(node) &&
            node.expression.kind === ts.SyntaxKind.ImportKeyword &&
            node.arguments.length === 1 &&
            ts.isStringLiteral(node.arguments[0])) {
            if (!this.ignoreStatement(node)) {
                const imp = this.getStringLiteralValue(node.arguments[0]);
                visitor(imp, filePath, project_graph_models_1.DependencyType.dynamic);
            }
            return;
        }
        if (ts.isCallExpression(node) &&
            node.expression.getText() === 'require' &&
            node.arguments.length === 1 &&
            ts.isStringLiteral(node.arguments[0])) {
            if (!this.ignoreStatement(node)) {
                const imp = this.getStringLiteralValue(node.arguments[0]);
                visitor(imp, filePath, project_graph_models_1.DependencyType.static);
            }
            return;
        }
        if (node.kind === ts.SyntaxKind.PropertyAssignment) {
            const name = this.getPropertyAssignmentName(node.name);
            if (name === 'loadChildren') {
                const init = node.initializer;
                if (init.kind === ts.SyntaxKind.StringLiteral &&
                    !this.ignoreLoadChildrenDependency(node.getFullText())) {
                    const childrenExpr = this.getStringLiteralValue(init);
                    visitor(childrenExpr, filePath, project_graph_models_1.DependencyType.dynamic);
                    return; // stop traversing downwards
                }
            }
        }
        /**
         * Continue traversing down the AST from the current node
         */
        ts.forEachChild(node, (child) => this.fromNode(filePath, child, visitor));
    }
    ignoreStatement(node) {
        return strip_source_code_1.stripSourceCode(this.scanner, node.getFullText()) === '';
    }
    ignoreLoadChildrenDependency(contents) {
        this.scanner.setText(contents);
        let token = this.scanner.scan();
        while (token !== ts.SyntaxKind.EndOfFileToken) {
            if (token === ts.SyntaxKind.SingleLineCommentTrivia ||
                token === ts.SyntaxKind.MultiLineCommentTrivia) {
                const start = this.scanner.getStartPos() + 2;
                token = this.scanner.scan();
                const isMultiLineCommentTrivia = token === ts.SyntaxKind.MultiLineCommentTrivia;
                const end = this.scanner.getStartPos() - (isMultiLineCommentTrivia ? 2 : 0);
                const comment = contents.substring(start, end).trim();
                if (comment === 'nx-ignore-next-line') {
                    return true;
                }
            }
            else {
                token = this.scanner.scan();
            }
        }
        return false;
    }
    getPropertyAssignmentName(nameNode) {
        switch (nameNode.kind) {
            case ts.SyntaxKind.Identifier:
                return nameNode.getText();
            case ts.SyntaxKind.StringLiteral:
                return nameNode.text;
            default:
                return null;
        }
    }
    getStringLiteralValue(node) {
        return node.getText().substr(1, node.getText().length - 2);
    }
}
exports.TypeScriptImportLocator = TypeScriptImportLocator;
//# sourceMappingURL=typescript-import-locator.js.map