"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkCircularPath = exports.getPath = void 0;
const operators_1 = require("../core/project-graph/operators");
const reach = {
    graph: null,
    matrix: null,
    adjList: null,
};
function buildMatrix(graph) {
    const dependencies = graph.dependencies;
    const nodes = Object.keys(graph.nodes).filter((s) => operators_1.isWorkspaceProject(graph.nodes[s]));
    const adjList = {};
    const matrix = {};
    const initMatrixValues = nodes.reduce((acc, value) => {
        return Object.assign(Object.assign({}, acc), { [value]: false });
    }, {});
    nodes.forEach((v, i) => {
        adjList[nodes[i]] = [];
        matrix[nodes[i]] = Object.assign({}, initMatrixValues);
    });
    for (let proj in dependencies) {
        for (let dep of dependencies[proj]) {
            if (operators_1.isWorkspaceProject(graph.nodes[dep.target])) {
                adjList[proj].push(dep.target);
            }
        }
    }
    const traverse = (s, v) => {
        matrix[s][v] = true;
        for (let adj of adjList[v]) {
            if (matrix[s][adj] === false) {
                traverse(s, adj);
            }
        }
    };
    nodes.forEach((v, i) => {
        traverse(nodes[i], nodes[i]);
    });
    return {
        matrix,
        adjList,
    };
}
function getPath(graph, sourceProjectName, targetProjectName) {
    if (sourceProjectName === targetProjectName)
        return [];
    if (reach.graph !== graph) {
        const result = buildMatrix(graph);
        reach.graph = graph;
        reach.matrix = result.matrix;
        reach.adjList = result.adjList;
    }
    const adjList = reach.adjList;
    let path = [];
    const queue = [[sourceProjectName, path]];
    const visited = [sourceProjectName];
    while (queue.length > 0) {
        const [current, p] = queue.pop();
        path = [...p, current];
        if (current === targetProjectName)
            break;
        if (!adjList[current])
            break;
        adjList[current]
            .filter((adj) => visited.indexOf(adj) === -1)
            .filter((adj) => reach.matrix[adj][targetProjectName])
            .forEach((adj) => {
            visited.push(adj);
            queue.push([adj, [...path]]);
        });
    }
    if (path.length > 1) {
        return path.map((n) => graph.nodes[n]);
    }
    else {
        return [];
    }
}
exports.getPath = getPath;
function checkCircularPath(graph, sourceProject, targetProject) {
    if (!graph.nodes[targetProject.name])
        return [];
    return getPath(graph, targetProject.name, sourceProject.name);
}
exports.checkCircularPath = checkCircularPath;
//# sourceMappingURL=graph-utils.js.map