"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRunner = exports.createTask = exports.runCommand = void 0;
const tslib_1 = require("tslib");
const tasks_runner_1 = require("./tasks-runner");
const path_1 = require("path");
const app_root_1 = require("../utilities/app-root");
const fileutils_1 = require("../utilities/fileutils");
const hasher_1 = require("../core/hasher/hasher");
const project_graph_utils_1 = require("../utilities/project-graph-utils");
const output_1 = require("../utilities/output");
function setParallelDefaults(options) { }
function runCommand(projectsToRun, projectGraph, { nxJson, workspaceResults }, nxArgs, overrides, reporter, initiatingProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { tasksRunner, runnerOptions } = getRunner(nxArgs, nxJson);
        // we have to special parallel because they can be overwritten in nx.json
        setParallelDefaults(runnerOptions);
        reporter.beforeRun(projectsToRun.map((p) => p.name), nxArgs, overrides);
        const tasks = projectsToRun.map((project) => {
            return createTask({
                project,
                target: nxArgs.target,
                configuration: nxArgs.configuration,
                overrides,
                errorIfCannotFindConfiguration: project.name === initiatingProject,
            });
        });
        const hasher = new hasher_1.Hasher(projectGraph, nxJson, runnerOptions);
        const res = yield hasher.hashTasks(tasks);
        for (let i = 0; i < res.length; ++i) {
            tasks[i].hash = res[i].value;
            tasks[i].hashDetails = res[i].details;
        }
        const cached = [];
        tasksRunner(tasks, runnerOptions, {
            initiatingProject,
            target: nxArgs.target,
            projectGraph,
            nxJson,
        }).subscribe({
            next: (event) => {
                switch (event.type) {
                    case tasks_runner_1.AffectedEventType.TaskComplete: {
                        workspaceResults.setResult(event.task.target.project, event.success);
                        break;
                    }
                    case tasks_runner_1.AffectedEventType.TaskCacheRead: {
                        workspaceResults.setResult(event.task.target.project, event.success);
                        cached.push(event.task.target.project);
                        break;
                    }
                }
            },
            error: console.error,
            complete: () => {
                // fix for https://github.com/nrwl/nx/issues/1666
                if (process.stdin['unref'])
                    process.stdin.unref();
                workspaceResults.saveResults();
                reporter.printResults(nxArgs, workspaceResults.failedProjects, workspaceResults.startedWithFailedProjects, cached);
                if (workspaceResults.hasFailure) {
                    process.exit(1);
                }
            },
        });
    });
}
exports.runCommand = runCommand;
function createTask({ project, target, configuration, overrides, errorIfCannotFindConfiguration, }) {
    if (!project_graph_utils_1.projectHasTarget(project, target)) {
        output_1.output.error({
            title: `Cannot find target '${target}' for project '${project.name}'`,
        });
        process.exit(1);
    }
    const config = project_graph_utils_1.projectHasTargetAndConfiguration(project, target, configuration)
        ? configuration
        : undefined;
    if (errorIfCannotFindConfiguration && configuration && !config) {
        output_1.output.error({
            title: `Cannot find configuration '${configuration}' for project '${project.name}'`,
        });
        process.exit(1);
    }
    const qualifiedTarget = {
        project: project.name,
        target,
        configuration: config,
    };
    return {
        id: getId(qualifiedTarget),
        target: qualifiedTarget,
        projectRoot: project.data.root,
        overrides: interpolateOverrides(overrides, project.name, project.data),
    };
}
exports.createTask = createTask;
function getId({ project, target, configuration, }) {
    let id = project + ':' + target;
    if (configuration) {
        id += ':' + configuration;
    }
    return id;
}
function getRunner(nxArgs, nxJson) {
    let runner = nxArgs.runner;
    //TODO: vsavkin remove in Nx 12
    if (!nxJson.tasksRunnerOptions) {
        const t = require('./default-tasks-runner');
        return {
            tasksRunner: t.defaultTasksRunner,
            runnerOptions: nxArgs,
        };
    }
    //TODO: vsavkin remove in Nx 12
    if (!runner && !nxJson.tasksRunnerOptions.default) {
        const t = require('./default-tasks-runner');
        return {
            tasksRunner: t.defaultTasksRunner,
            runnerOptions: nxArgs,
        };
    }
    runner = runner || 'default';
    if (nxJson.tasksRunnerOptions[runner]) {
        let modulePath = nxJson.tasksRunnerOptions[runner].runner;
        let tasksRunner;
        if (modulePath) {
            if (fileutils_1.isRelativePath(modulePath)) {
                modulePath = path_1.join(app_root_1.appRootPath, modulePath);
            }
            tasksRunner = require(modulePath);
            // to support both babel and ts formats
            if (tasksRunner.default) {
                tasksRunner = tasksRunner.default;
            }
        }
        else {
            tasksRunner = require('./default-tasks-runner').defaultTasksRunner;
        }
        return {
            tasksRunner,
            runnerOptions: Object.assign(Object.assign({}, nxJson.tasksRunnerOptions[runner].options), nxArgs),
        };
    }
    else {
        output_1.output.error({
            title: `Could not find runner configuration for ${runner}`,
        });
        process.exit(1);
    }
}
exports.getRunner = getRunner;
function interpolateOverrides(args, projectName, projectMetadata) {
    const interpolatedArgs = Object.assign({}, args);
    Object.entries(interpolatedArgs).forEach(([name, value]) => {
        if (typeof value === 'string') {
            const regex = /{project\.([^}]+)}/g;
            interpolatedArgs[name] = value.replace(regex, (_, group) => {
                if (group.includes('.')) {
                    throw new Error('Only top-level properties can be interpolated');
                }
                if (group === 'name') {
                    return projectName;
                }
                return projectMetadata[group];
            });
        }
    });
    return interpolatedArgs;
}
//# sourceMappingURL=run-command.js.map