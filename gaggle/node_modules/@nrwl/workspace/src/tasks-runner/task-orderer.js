"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskOrderer = void 0;
const graph_utils_1 = require("../utils/graph-utils");
class TaskOrderer {
    constructor(options, target, projectGraph) {
        this.options = options;
        this.target = target;
        this.projectGraph = projectGraph;
    }
    splitTasksIntoStages(tasks) {
        if ((this.options.strictlyOrderedTargets || ['build']).indexOf(this.target) === -1)
            return [tasks];
        if (tasks.length === 0)
            return [];
        const res = [];
        this.topologicallySortTasks(tasks).forEach((t) => {
            const stageWithNoDeps = res.find((tasksInStage) => !this.taskDependsOnDeps(t, tasksInStage));
            if (stageWithNoDeps) {
                stageWithNoDeps.push(t);
            }
            else {
                res.push([t]);
            }
        });
        return res;
    }
    taskDependsOnDeps(task, deps) {
        return !!deps.find((dep) => graph_utils_1.getPath(this.projectGraph, task.target.project, dep.target.project)
            .length > 0);
    }
    topologicallySortTasks(tasks) {
        const visited = {};
        const sorted = [];
        const visitNode = (id) => {
            if (visited[id])
                return;
            visited[id] = true;
            this.projectGraph.dependencies[id].forEach((d) => {
                visitNode(d.target);
            });
            sorted.push(id);
        };
        tasks.forEach((t) => visitNode(t.target.project));
        const sortedTasks = [...tasks];
        sortedTasks.sort((a, b) => sorted.indexOf(a.target.project) > sorted.indexOf(b.target.project)
            ? 1
            : -1);
        return sortedTasks;
    }
}
exports.TaskOrderer = TaskOrderer;
//# sourceMappingURL=task-orderer.js.map