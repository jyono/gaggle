"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReactEslintJson = exports.extraEslintDependencies = void 0;
const devkit_1 = require("@nrwl/devkit");
const versions_1 = require("./versions");
exports.extraEslintDependencies = {
    dependencies: {},
    devDependencies: {
        'eslint-plugin-import': versions_1.eslintPluginImportVersion,
        'eslint-plugin-jsx-a11y': versions_1.eslintPluginJsxA11yVersion,
        'eslint-plugin-react': versions_1.eslintPluginReactVersion,
        'eslint-plugin-react-hooks': versions_1.eslintPluginReactHooksVersion,
    },
};
exports.createReactEslintJson = (projectRoot) => ({
    extends: [
        'plugin:@nrwl/nx/react',
        `${devkit_1.offsetFromRoot(projectRoot)}.eslintrc.json`,
    ],
    ignorePatterns: ['!**/*'],
    overrides: [
        {
            files: ['*.ts', '*.tsx', '*.js', '*.jsx'],
            parserOptions: {
                /**
                 * In order to ensure maximum efficiency when typescript-eslint generates TypeScript Programs
                 * behind the scenes during lint runs, we need to make sure the project is configured to use its
                 * own specific tsconfigs, and not fall back to the ones in the root of the workspace.
                 */
                project: [`${projectRoot}/tsconfig.*?.json`],
            },
            /**
             * Having an empty rules object present makes it more obvious to the user where they would
             * extend things from if they needed to
             */
            rules: {},
        },
        {
            files: ['*.ts', '*.tsx'],
            rules: {},
        },
        {
            files: ['*.js', '*.jsx'],
            rules: {},
        },
    ],
});
//# sourceMappingURL=lint.js.map