"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.librarySchematic = exports.libraryGenerator = void 0;
const tslib_1 = require("tslib");
const styled_1 = require("../../utils/styled");
const ts = require("typescript");
const assertion_1 = require("../../utils/assertion");
const ast_utils_1 = require("../../utils/ast-utils");
const lint_1 = require("../../utils/lint");
const versions_1 = require("../../utils/versions");
const devkit_1 = require("@nrwl/devkit");
const run_tasks_in_serial_1 = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const init_1 = require("../init/init");
const linter_1 = require("@nrwl/linter");
const jest_1 = require("@nrwl/jest");
const component_1 = require("../component/component");
function libraryGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tasks = [];
        const options = normalizeOptions(host, schema);
        if (options.publishable === true && !schema.importPath) {
            throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
        }
        if (!options.component) {
            options.style = 'none';
        }
        const initTask = yield init_1.default(host, Object.assign(Object.assign({}, options), { e2eTestRunner: 'none', skipFormat: true }));
        tasks.push(initTask);
        addProject(host, options);
        const lintTask = yield addLinting(host, options);
        tasks.push(lintTask);
        createFiles(host, options);
        if (!options.skipTsConfig) {
            updateTsConfig(host, options);
        }
        if (options.unitTestRunner === 'jest') {
            const jestTask = yield jest_1.jestProjectGenerator(host, {
                project: options.name,
                setupFile: 'none',
                supportTsx: true,
                skipSerializers: true,
                babelJest: true,
            });
            tasks.push(jestTask);
        }
        if (options.component) {
            const componentTask = yield component_1.default(host, {
                name: options.name,
                project: options.name,
                flat: true,
                style: options.style,
                skipTests: options.unitTestRunner === 'none',
                export: true,
                routing: options.routing,
                js: options.js,
                pascalCaseFiles: options.pascalCaseFiles,
            });
            tasks.push(componentTask);
        }
        if (options.publishable || options.buildable) {
            updateLibPackageNpmScope(host, options);
        }
        const installTask = yield devkit_1.addDependenciesToPackageJson(host, {
            react: versions_1.reactVersion,
            'react-dom': versions_1.reactDomVersion,
        }, {});
        tasks.push(installTask);
        const routeTask = updateAppRoutes(host, options);
        tasks.push(routeTask);
        if (!options.skipFormat) {
            yield devkit_1.formatFiles(host);
        }
        return run_tasks_in_serial_1.runTasksInSerial(...tasks);
    });
}
exports.libraryGenerator = libraryGenerator;
function addLinting(host, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const lintTask = yield linter_1.lintProjectGenerator(host, {
            linter: options.linter,
            project: options.name,
            tsConfigPaths: [
                devkit_1.joinPathFragments(options.projectRoot, 'tsconfig.lib.json'),
            ],
            eslintFilePatterns: [`${options.projectRoot}/**/*.{ts,tsx,js,jsx}`],
            skipFormat: true,
        });
        if (options.linter === linter_1.Linter.TsLint) {
            return;
        }
        const reactEslintJson = lint_1.createReactEslintJson(options.projectRoot);
        devkit_1.updateJson(host, devkit_1.joinPathFragments(options.projectRoot, '.eslintrc.json'), () => reactEslintJson);
        const installTask = yield devkit_1.addDependenciesToPackageJson(host, lint_1.extraEslintDependencies.dependencies, lint_1.extraEslintDependencies.devDependencies);
        return run_tasks_in_serial_1.runTasksInSerial(lintTask, installTask);
    });
}
function addProject(host, options) {
    const targets = {};
    if (options.publishable || options.buildable) {
        const { libsDir } = devkit_1.getWorkspaceLayout(host);
        const external = ['react', 'react-dom'];
        // Also exclude CSS-in-JS packages from build
        if (options.style !== 'css' &&
            options.style !== 'scss' &&
            options.style !== 'styl' &&
            options.style !== 'less' &&
            options.style !== 'none') {
            external.push(...Object.keys(styled_1.CSS_IN_JS_DEPENDENCIES[options.style].dependencies));
        }
        targets.build = {
            builder: '@nrwl/web:package',
            outputs: ['{options.outputPath}'],
            options: {
                outputPath: `dist/${libsDir}/${options.projectDirectory}`,
                tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
                project: `${options.projectRoot}/package.json`,
                entryFile: maybeJs(options, `${options.projectRoot}/src/index.ts`),
                external,
                babelConfig: `@nrwl/react/plugins/bundle-babel`,
                rollupConfig: `@nrwl/react/plugins/bundle-rollup`,
                assets: [
                    {
                        glob: 'README.md',
                        input: '.',
                        output: '.',
                    },
                ],
            },
        };
    }
    devkit_1.addProjectConfiguration(host, options.name, {
        root: options.projectRoot,
        sourceRoot: devkit_1.joinPathFragments(options.projectRoot, 'src'),
        projectType: 'library',
        tags: options.parsedTags,
        targets,
    });
}
function updateTsConfig(host, options) {
    devkit_1.updateJson(host, 'tsconfig.base.json', (json) => {
        const c = json.compilerOptions;
        c.paths = c.paths || {};
        delete c.paths[options.name];
        if (c.paths[options.importPath]) {
            throw new Error(`You already have a library using the import path "${options.importPath}". Make sure to specify a unique one.`);
        }
        const { libsDir } = devkit_1.getWorkspaceLayout(host);
        c.paths[options.importPath] = [
            maybeJs(options, `${libsDir}/${options.projectDirectory}/src/index.ts`),
        ];
        return json;
    });
}
function createFiles(host, options) {
    devkit_1.generateFiles(host, devkit_1.joinPathFragments(__dirname, './files/lib'), options.projectRoot, Object.assign(Object.assign(Object.assign({}, options), devkit_1.names(options.name)), { tmpl: '', offsetFromRoot: devkit_1.offsetFromRoot(options.projectRoot) }));
    if (!options.publishable && !options.buildable) {
        host.delete(`${options.projectRoot}/package.json`);
    }
    if (options.js) {
        devkit_1.toJS(host);
    }
}
function updateAppRoutes(host, options) {
    if (!options.appMain || !options.appSourceRoot) {
        return () => { };
    }
    const { content, source } = readComponent(host, options.appMain);
    const componentImportPath = ast_utils_1.findComponentImportPath('App', source);
    if (!componentImportPath) {
        throw new Error(`Could not find App component in ${options.appMain} (Hint: you can omit --appProject, or make sure App exists)`);
    }
    const appComponentPath = devkit_1.joinPathFragments(options.appSourceRoot, maybeJs(options, `${componentImportPath}.tsx`));
    const routerTask = devkit_1.addDependenciesToPackageJson(host, { 'react-router-dom': versions_1.reactRouterDomVersion }, { '@types/react-router-dom': versions_1.typesReactRouterDomVersion });
    // addBrowserRouterToMain
    const isRouterPresent = content.match(/react-router-dom/);
    if (!isRouterPresent) {
        const changes = devkit_1.applyChangesToString(content, ast_utils_1.addBrowserRouter(options.appMain, source));
        host.write(options.appMain, changes);
    }
    // addInitialAppRoutes
    {
        const { content: componentContent, source: componentSource, } = readComponent(host, appComponentPath);
        const isComponentRouterPresent = componentContent.match(/react-router-dom/);
        if (!isComponentRouterPresent) {
            const changes = devkit_1.applyChangesToString(componentContent, ast_utils_1.addInitialRoutes(appComponentPath, componentSource));
            host.write(appComponentPath, changes);
        }
    }
    // addNewAppRoute
    {
        const { content: componentContent, source: componentSource, } = readComponent(host, appComponentPath);
        const { npmScope } = devkit_1.getWorkspaceLayout(host);
        const changes = devkit_1.applyChangesToString(componentContent, ast_utils_1.addRoute(appComponentPath, componentSource, {
            routePath: options.routePath,
            componentName: devkit_1.names(options.name).className,
            moduleName: `@${npmScope}/${options.projectDirectory}`,
        }));
        host.write(appComponentPath, changes);
    }
    return routerTask;
}
function readComponent(host, path) {
    if (!host.exists(path)) {
        throw new Error(`Cannot find ${path}`);
    }
    const content = host.read(path).toString('utf-8');
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return { content, source };
}
function normalizeOptions(host, options) {
    const name = devkit_1.names(options.name).fileName;
    const projectDirectory = options.directory
        ? `${devkit_1.names(options.directory).fileName}/${name}`
        : name;
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const fileName = projectName;
    const { libsDir, npmScope } = devkit_1.getWorkspaceLayout(host);
    const projectRoot = devkit_1.joinPathFragments(`${libsDir}/${projectDirectory}`);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    const importPath = options.importPath || `@${npmScope}/${projectDirectory}`;
    const normalized = Object.assign(Object.assign({}, options), { fileName, routePath: `/${name}`, name: projectName, projectRoot,
        projectDirectory,
        parsedTags,
        importPath });
    if (options.appProject) {
        const appProjectConfig = devkit_1.getProjects(host).get(options.appProject);
        if (appProjectConfig.projectType !== 'application') {
            throw new Error(`appProject expected type of "application" but got "${appProjectConfig.projectType}"`);
        }
        try {
            normalized.appMain = appProjectConfig.targets.build.options.main;
            normalized.appSourceRoot = devkit_1.normalizePath(appProjectConfig.sourceRoot);
        }
        catch (e) {
            throw new Error(`Could not locate project main for ${options.appProject}`);
        }
    }
    assertion_1.assertValidStyle(normalized.style);
    return normalized;
}
function updateLibPackageNpmScope(host, options) {
    return devkit_1.updateJson(host, `${options.projectRoot}/package.json`, (json) => {
        json.name = options.importPath;
        return json;
    });
}
function maybeJs(options, path) {
    return options.js && (path.endsWith('.ts') || path.endsWith('.tsx'))
        ? path.replace(/\.tsx?$/, '.js')
        : path;
}
exports.default = libraryGenerator;
exports.librarySchematic = devkit_1.convertNxGenerator(libraryGenerator);
//# sourceMappingURL=library.js.map