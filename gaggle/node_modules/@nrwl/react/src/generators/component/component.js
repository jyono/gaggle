"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentSchematic = exports.componentGenerator = void 0;
const tslib_1 = require("tslib");
const ts = require("typescript");
const versions_1 = require("../../utils/versions");
const assertion_1 = require("../../utils/assertion");
const add_styled_dependencies_1 = require("../../rules/add-styled-dependencies");
const devkit_1 = require("@nrwl/devkit");
const run_tasks_in_serial_1 = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const ast_utils_1 = require("../../utils/ast-utils");
function componentGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = yield normalizeOptions(host, schema);
        createComponentFiles(host, options);
        const tasks = [];
        const styledTask = add_styled_dependencies_1.addStyledModuleDependencies(host, options.styledModule);
        tasks.push(styledTask);
        addExportsToBarrel(host, options);
        if (options.routing) {
            const routingTask = devkit_1.addDependenciesToPackageJson(host, { 'react-router-dom': versions_1.reactRouterDomVersion }, { '@types/react-router-dom': versions_1.typesReactRouterDomVersion });
            tasks.push(routingTask);
        }
        yield devkit_1.formatFiles(host);
        return run_tasks_in_serial_1.runTasksInSerial(...tasks);
    });
}
exports.componentGenerator = componentGenerator;
function createComponentFiles(host, options) {
    const componentDir = devkit_1.joinPathFragments(options.projectSourceRoot, options.directory);
    devkit_1.generateFiles(host, devkit_1.joinPathFragments(__dirname, './files'), componentDir, Object.assign(Object.assign({}, options), { tmpl: '' }));
    for (const c of host.listChanges()) {
        let deleteFile = false;
        if (options.skipTests && /.*spec.tsx/.test(c.path)) {
            deleteFile = true;
        }
        if ((options.styledModule || !options.hasStyles) &&
            c.path.endsWith(`.${options.style}`)) {
            deleteFile = true;
        }
        if (options.globalCss && c.path.endsWith(`.module.${options.style}`)) {
            deleteFile = true;
        }
        if (!options.globalCss &&
            c.path.endsWith(`${options.fileName}.${options.style}`)) {
            deleteFile = true;
        }
        if (deleteFile) {
            host.delete(c.path);
        }
    }
    if (options.js) {
        devkit_1.toJS(host);
    }
}
function addExportsToBarrel(host, options) {
    const workspace = devkit_1.getProjects(host);
    const isApp = workspace.get(options.project).projectType === 'application';
    if (options.export && !isApp) {
        const indexFilePath = devkit_1.joinPathFragments(options.projectSourceRoot, options.js ? 'index.js' : 'index.ts');
        const buffer = host.read(indexFilePath);
        if (!!buffer) {
            const indexSource = buffer.toString('utf-8');
            const indexSourceFile = ts.createSourceFile(indexFilePath, indexSource, ts.ScriptTarget.Latest, true);
            const changes = devkit_1.applyChangesToString(indexSource, ast_utils_1.addImport(indexSourceFile, `export * from './${options.directory}/${options.fileName}';`));
            host.write(indexFilePath, changes);
        }
    }
}
function normalizeOptions(host, options) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        assertValidOptions(options);
        const { className, fileName } = devkit_1.names(options.name);
        const componentFileName = options.pascalCaseFiles ? className : fileName;
        const project = devkit_1.getProjects(host).get(options.project);
        if (!project) {
            devkit_1.logger.error(`Cannot find the ${options.project} project. Please double check the project name.`);
            throw new Error();
        }
        const { sourceRoot: projectSourceRoot, projectType } = project;
        const directory = yield getDirectory(host, options);
        const styledModule = /^(css|scss|less|styl|none)$/.test(options.style)
            ? null
            : options.style;
        if (options.export && projectType === 'application') {
            devkit_1.logger.warn(`The "--export" option should not be used with applications and will do nothing.`);
        }
        options.classComponent = (_a = options.classComponent) !== null && _a !== void 0 ? _a : false;
        options.routing = (_b = options.routing) !== null && _b !== void 0 ? _b : false;
        options.globalCss = (_c = options.globalCss) !== null && _c !== void 0 ? _c : false;
        return Object.assign(Object.assign({}, options), { directory,
            styledModule, hasStyles: options.style !== 'none', className, fileName: componentFileName, projectSourceRoot });
    });
}
function getDirectory(host, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fileName = devkit_1.names(options.name).fileName;
        const workspace = devkit_1.getProjects(host);
        let baseDir;
        if (options.directory) {
            baseDir = options.directory;
        }
        else {
            baseDir =
                workspace.get(options.project).projectType === 'application'
                    ? 'app'
                    : 'lib';
        }
        return options.flat ? baseDir : devkit_1.joinPathFragments(baseDir, fileName);
    });
}
function assertValidOptions(options) {
    assertion_1.assertValidStyle(options.style);
    const slashes = ['/', '\\'];
    slashes.forEach((s) => {
        if (options.name.indexOf(s) !== -1) {
            const [name, ...rest] = options.name.split(s).reverse();
            let suggestion = rest.map((x) => x.toLowerCase()).join(s);
            if (options.directory) {
                suggestion = `${options.directory}${s}${suggestion}`;
            }
            throw new Error(`Found "${s}" in the component name. Did you mean to use the --directory option (e.g. \`nx g c ${name} --directory ${suggestion}\`)?`);
        }
    });
}
exports.default = componentGenerator;
exports.componentSchematic = devkit_1.convertNxGenerator(componentGenerator);
//# sourceMappingURL=component.js.map