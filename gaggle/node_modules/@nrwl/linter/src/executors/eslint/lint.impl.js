"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eslint_1 = require("eslint");
const fs_1 = require("fs");
const path_1 = require("path");
const eslint_utils_1 = require("./utility/eslint-utils");
const create_directory_1 = require("./utility/create-directory");
function run(options, context) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const systemRoot = context.root;
        process.chdir(context.cwd);
        const projectName = context.projectName || '<???>';
        const printInfo = options.format && !options.silent;
        if (printInfo) {
            console.info(`\nLinting ${JSON.stringify(projectName)}...`);
        }
        const projectESLint = yield eslint_utils_1.loadESLint();
        const version = (_b = (_a = projectESLint.ESLint) === null || _a === void 0 ? void 0 : _a.version) === null || _b === void 0 ? void 0 : _b.split('.');
        if (!version ||
            version.length < 2 ||
            Number(version[0]) < 7 ||
            (Number(version[0]) === 7 && Number(version[1]) < 6)) {
            throw new Error('ESLint must be version 7.6 or higher.');
        }
        const eslint = new projectESLint.ESLint({});
        /**
         * We want users to have the option of not specifying the config path, and let
         * eslint automatically resolve the `.eslintrc.json` files in each folder.
         */
        const eslintConfigPath = options.eslintConfig
            ? path_1.resolve(systemRoot, options.eslintConfig)
            : undefined;
        let lintResults = yield eslint_utils_1.lint(eslintConfigPath, options);
        if (lintResults.length === 0) {
            throw new Error('Invalid lint configuration. Nothing to lint.');
        }
        // if quiet, only show errors
        if (options.quiet) {
            console.debug('Quiet mode enabled - filtering out warnings\n');
            lintResults = eslint_1.ESLint.getErrorResults(lintResults);
        }
        const formatter = yield eslint.loadFormatter(options.format);
        let totalErrors = 0;
        let totalWarnings = 0;
        // output fixes to disk, if applicable based on the options
        yield projectESLint.ESLint.outputFixes(lintResults);
        for (const result of lintResults) {
            if (result.errorCount || result.warningCount) {
                totalErrors += result.errorCount;
                totalWarnings += result.warningCount;
            }
        }
        const formattedResults = formatter.format(lintResults);
        if (options.outputFile) {
            const pathToOutputFile = path_1.join(context.root, options.outputFile);
            create_directory_1.createDirectory(path_1.dirname(pathToOutputFile));
            fs_1.writeFileSync(pathToOutputFile, formattedResults);
        }
        else {
            console.info(formattedResults);
        }
        if (totalWarnings > 0 && printInfo) {
            console.warn('Lint warnings found in the listed files.\n');
        }
        if (totalErrors > 0 && printInfo) {
            console.error('Lint errors found in the listed files.\n');
        }
        if (totalWarnings === 0 && totalErrors === 0 && printInfo) {
            console.info('All files pass linting.\n');
        }
        return {
            success: options.force ||
                (totalErrors === 0 &&
                    (options.maxWarnings === -1 || totalWarnings <= options.maxWarnings)),
        };
    });
}
exports.default = run;
//# sourceMappingURL=lint.impl.js.map