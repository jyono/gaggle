"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintProjectGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const linter_1 = require("../utils/linter");
const init_1 = require("../init/init");
function createTsLintConfiguration(tree, projectConfig) {
    devkit_1.writeJson(tree, path_1.join(projectConfig.root, `tslint.json`), {
        extends: `${devkit_1.offsetFromRoot(projectConfig.root)}tslint.json`,
        // Include project files to be linted since the global one excludes all files.
        linterOptions: {
            exclude: ['!**/*'],
        },
        rules: {},
    });
}
function createEsLintConfiguration(tree, projectConfig) {
    devkit_1.writeJson(tree, path_1.join(projectConfig.root, `.eslintrc.json`), {
        extends: [`${devkit_1.offsetFromRoot(projectConfig.root)}.eslintrc.json`],
        // Include project files to be linted since the global one excludes all files.
        ignorePatterns: ['!**/*'],
        overrides: [
            {
                files: ['*.ts', '*.tsx', '*.js', '*.jsx'],
                parserOptions: {
                    /**
                     * In order to ensure maximum efficiency when typescript-eslint generates TypeScript Programs
                     * behind the scenes during lint runs, we need to make sure the project is configured to use its
                     * own specific tsconfigs, and not fall back to the ones in the root of the workspace.
                     */
                    project: [`${projectConfig.root}/tsconfig.*?.json`],
                },
                /**
                 * Having an empty rules object present makes it more obvious to the user where they would
                 * extend things from if they needed to
                 */
                rules: {},
            },
            {
                files: ['*.ts', '*.tsx'],
                rules: {},
            },
            {
                files: ['*.js', '*.jsx'],
                rules: {},
            },
        ],
    });
}
function lintProjectGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installTask = init_1.lintInitGenerator(tree, {
            linter: options.linter,
        });
        const projectConfig = devkit_1.readProjectConfiguration(tree, options.project);
        if (options.linter === linter_1.Linter.EsLint) {
            projectConfig.targets['lint'] = {
                executor: '@nrwl/linter:eslint',
                options: {
                    lintFilePatterns: options.eslintFilePatterns,
                },
            };
            createEsLintConfiguration(tree, projectConfig);
        }
        else {
            projectConfig.targets['lint'] = {
                executor: '@angular-devkit/build-angular:tslint',
                options: {
                    tsConfig: options.tsConfigPaths,
                    exclude: ['**/node_modules/**', '!' + projectConfig.root + '/**/*'],
                },
            };
            createTsLintConfiguration(tree, projectConfig);
        }
        devkit_1.updateProjectConfiguration(tree, options.project, projectConfig);
        if (!options.skipFormat) {
            yield devkit_1.formatFiles(tree);
        }
        return installTask;
    });
}
exports.lintProjectGenerator = lintProjectGenerator;
//# sourceMappingURL=lint-project.js.map